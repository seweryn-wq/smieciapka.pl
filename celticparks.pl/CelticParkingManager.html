<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parking Management System - Celtic Park Piaseczno</title>
    <style>
        /* ============================================
           GLOBAL STYLES
           ============================================ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            color: #333;
            overflow: hidden;
        }

        /* ============================================
           HEADER & NAVIGATION
           ============================================ */
        .header {
            background: linear-gradient(135deg, #303030 0%, #1a1a1a 100%);
            color: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header-top {
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .header-logo {
            height: 48px;
            width: auto;
        }

        .header-text h1 {
            font-size: 1.5rem;
            margin-bottom: 0.3rem;
        }

        .header-text p {
            opacity: 0.9;
            font-size: 0.85rem;
        }

        .header-controls {
            display: flex;
            gap: 0.8rem;
        }

        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            padding: 0 2rem;
            gap: 0.5rem;
            justify-content: space-between;
            align-items: center;
        }

        .tab-group-left {
            display: flex;
            gap: 0.5rem;
        }

        .tab-group-right {
            display: flex;
            gap: 0.5rem;
        }

        .tab-btn {
            padding: 0.8rem 1.5rem;
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.7);
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .tab-btn:hover {
            color: white;
            background: rgba(255,255,255,0.1);
        }

        .tab-btn.active {
            color: white;
            border-bottom-color: white;
            background: rgba(255,255,255,0.1);
        }

        /* Responsive: stack vertically on smaller screens */
        @media (max-width: 1024px) {
            .tab-navigation {
                flex-direction: column;
                align-items: stretch;
                gap: 0.5rem;
                padding: 0.5rem 1rem;
            }

            .tab-group-left,
            .tab-group-right {
                justify-content: center;
            }

            .tab-btn {
                padding: 0.6rem 1rem;
                font-size: 0.85rem;
            }
        }

        /* ============================================
           VENDORS TAB - SPECIFIC STYLES
           ============================================ */
        .vendors-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 2rem;
            background: #f5f5f5;
        }

        .vendors-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .vendors-header h2 {
            font-size: 1.8rem;
            color: #333;
        }

        .vendors-table-container {
            flex: 1;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .vendors-table-wrapper {
            flex: 1;
            overflow-y: auto;
        }

        .vendors-table {
            width: 100%;
            border-collapse: collapse;
        }

        .vendors-table thead {
            position: sticky;
            top: 0;
            background: #303030;
            color: white;
            z-index: 10;
        }

        .vendors-table th {
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .vendors-table th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 2rem;
        }

        .vendors-table th.sortable:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .vendors-table th.sortable::after {
            content: '‚áÖ';
            position: absolute;
            right: 0.5rem;
            opacity: 0.3;
            font-size: 0.8rem;
        }

        .vendors-table th.sortable.sort-asc::after {
            content: '‚ñ≤';
            opacity: 1;
        }

        .vendors-table th.sortable.sort-desc::after {
            content: '‚ñº';
            opacity: 1;
        }

        .vendors-table td {
            padding: 1rem;
            border-bottom: 1px solid #e0e0e0;
        }

        .vendors-table tbody tr {
            transition: background 0.2s;
        }

        .vendors-table tbody tr:hover {
            background: #f8f9fa;
        }

        .vendors-table tbody tr:last-child td {
            border-bottom: none;
        }

        .vendors-table td.nowrap {
            white-space: nowrap;
        }

        .vendor-actions {
            display: flex;
            gap: 0.5rem;
        }

        .btn-icon {
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .btn-edit {
            background: #3b82f6;
            color: white;
        }

        .btn-edit:hover {
            background: #2563eb;
        }

        .btn-delete {
            background: #ef4444;
            color: white;
        }

        .btn-delete:hover {
            background: #dc2626;
        }

        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: #666;
        }

        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }

        .empty-state-text {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        .empty-state-hint {
            font-size: 0.9rem;
            opacity: 0.7;
        }

        /* Modal for vendor form */
        .vendor-modal-content {
            max-width: 500px;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            font-size: 0.9rem;
            font-weight: 500;
            color: #333;
            margin-bottom: 0.5rem;
        }

        .form-group label .required {
            color: #ef4444;
            margin-left: 0.2rem;
        }

        .form-group input {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 0.95rem;
            transition: border-color 0.2s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #303030;
        }

        .form-group input.error {
            border-color: #ef4444;
        }

        .form-error {
            color: #ef4444;
            font-size: 0.85rem;
            margin-top: 0.3rem;
            display: none;
        }

        .form-error.show {
            display: block;
        }

        /* ============================================
           PRICES TAB - SPECIFIC STYLES
           ============================================ */
        .prices-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 2rem;
            background: #f5f5f5;
        }

        .prices-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .prices-header h2 {
            font-size: 1.8rem;
            color: #333;
        }

        .prices-table-container {
            flex: 1;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .prices-table-wrapper {
            flex: 1;
            overflow-y: auto;
        }

        .prices-table {
            width: 100%;
            border-collapse: collapse;
        }

        .prices-table thead {
            position: sticky;
            top: 0;
            background: #303030;
            color: white;
            z-index: 10;
        }

        .prices-table th {
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .prices-table td {
            padding: 1rem;
            border-bottom: 1px solid #e0e0e0;
        }

        .prices-table tbody tr {
            transition: background 0.2s;
        }

        .prices-table tbody tr:hover {
            background: #f8f9fa;
        }

        .prices-table tbody tr:last-child td {
            border-bottom: none;
        }

        .price-value {
            font-weight: 600;
            color: #10b981;
            font-size: 1.1rem;
        }

        .price-modal-content {
            max-width: 450px;
        }

        /* ============================================
           BUTTON STYLES
           ============================================ */
        .btn {
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .btn-primary {
            background: white;
            color: #303030;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255,255,255,0.3);
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover {
            background: #059669;
            transform: translateY(-2px);
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
        }

        .btn-warning:hover {
            background: #d97706;
        }

        .btn-secondary {
            background: #6b7280;
            color: white;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        /* ============================================
           TAB CONTENT CONTAINER
           ============================================ */
        .tab-content {
            display: none;
            height: calc(100vh - 140px);
        }

        .tab-content.active {
            display: flex;
        }

        /* ============================================
           SIDEBAR STYLES (SHARED)
           ============================================ */
        .sidebar {
            width: 350px;
            background: white;
            box-shadow: 2px 0 10px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 1.5rem;
            border-bottom: 2px solid #e0e0e0;
            background: #f8f9fa;
        }

        .sidebar-header h2 {
            font-size: 1.2rem;
            color: #303030;
            margin-bottom: 0;
        }

        /* ============================================
           MAP AREA (SHARED)
           ============================================ */
        .map-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #e5e7eb;
        }

        .map-toolbar {
            padding: 1rem;
            background: white;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .zoom-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .zoom-btn {
            background: #e0e0e0;
            border: none;
            border-radius: 4px;
            width: 36px;
            height: 36px;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: #d0d0d0;
        }

        .zoom-level {
            font-size: 0.9rem;
            color: #666;
            width: 70px;
            text-align: center;
            border: 2px solid #e0e0e0;
            border-radius: 4px;
            padding: 0.4rem;
            background: white;
            font-weight: 500;
        }

        .zoom-level:focus {
            outline: none;
            border-color: #303030;
        }

        .map-container {
            flex: 1;
            overflow: auto;
            position: relative;
            background: #e5e7eb;
        }

        /* Panning cursor states */
        .map-container.can-pan {
            cursor: grab;
        }

        .map-container.is-panning {
            cursor: grabbing;
            user-select: none;
        }

        .map-scale-container {
            display: inline-block;
            transform-origin: top left;
        }

        .map-wrapper {
            position: relative;
            display: inline-block;
        }

        .map-image {
            display: block;
            width: 100%;
            height: auto;
            user-select: none;
            pointer-events: none;
        }

        .spots-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* ============================================
           DESIGNER TAB - SPECIFIC STYLES
           ============================================ */
        .spot-list-controls {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e0e0e0;
            background: white;
        }

        .add-spot-form {
            display: flex;
            gap: 0.5rem;
        }

        .add-spot-form input {
            flex: 1;
            padding: 0.6rem;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .add-spot-form input:focus {
            outline: none;
            border-color: #303030;
        }

        .add-spot-form button {
            padding: 0.6rem 1rem;
            background: #303030;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
        }

        .add-spot-form button:hover {
            background: #5568d3;
        }

        .stats-bar {
            padding: 0.8rem 1.5rem;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            font-size: 0.85rem;
            color: #666;
        }

        .control-panel {
            padding: 1rem 1.5rem;
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
            display: none;
        }

        .control-panel h3 {
            font-size: 0.9rem;
            color: #303030;
            margin-bottom: 0.8rem;
        }

        .control-group {
            margin-bottom: 0.8rem;
        }

        .control-group label {
            display: block;
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 0.3rem;
        }

        .spinner-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .spinner-control button {
            width: 32px;
            height: 32px;
            border: 1px solid #303030;
            background: white;
            color: #303030;
            border-radius: 4px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .spinner-control button:hover {
            background: #303030;
            color: white;
        }

        .spinner-control input[type="number"] {
            flex: 1;
            text-align: center;
            padding: 0.5rem;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .spinner-control input[type="number"]::-webkit-inner-spin-button,
        .spinner-control input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .spinner-control input[type="number"] {
            -moz-appearance: textfield;
        }

        .spots-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 1.5rem;
        }

        .spot-item {
            padding: 0.8rem;
            margin-bottom: 0.6rem;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 3px solid #303030;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .spot-item:hover {
            background: #e0e7ff;
            transform: translateX(4px);
        }

        .spot-item.active {
            background: #303030;
            color: white;
            font-weight: bold;
        }

        .spot-item.positioned {
            border-left-color: #10b981;
        }

        .spot-info {
            flex: 1;
        }

        .spot-number {
            font-weight: 600;
            font-size: 0.95rem;
        }

        .spot-coords {
            font-size: 0.7rem;
            margin-top: 0.2rem;
            font-weight: 500;
        }

        .spot-mapped {
            color: #10b981;
            opacity: 0.9;
        }

        .spot-unmapped {
            color: #ef4444;
            opacity: 0.9;
        }

        .spot-assigned {
            color: #3b82f6;
            opacity: 0.9;
        }

        .spot-actions {
            display: flex;
            gap: 0.3rem;
        }

        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            font-size: 1rem;
            opacity: 0.6;
            transition: all 0.2s;
        }

        .icon-btn:hover {
            opacity: 1;
            background: rgba(0,0,0,0.1);
        }

        .spot-item.active .icon-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Parking rectangles for Designer */
        .parking-rect {
            position: absolute;
            border: 1px solid #f59e0b;
            background: rgba(245, 158, 11, 0.2);
            cursor: move;
            pointer-events: all;
            transition: all 0.1s;
        }

        .parking-rect:hover {
            border-color: #f59e0b;
            background: rgba(245, 158, 11, 0.3);
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            z-index: 10;
        }

        .parking-rect.selected {
            border-color: #10b981;
            border-width: 1px;
            background: rgba(16, 185, 129, 0.2);
            z-index: 100;
        }

        .parking-rect.dragging {
            cursor: grabbing;
            z-index: 1000;
        }

        .spot-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 5px;
            font-weight: 600;
            color: #303030;
            pointer-events: none;
            white-space: nowrap;
            letter-spacing: -0.3px;
        }

        .selection-hint {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: #303030;
            color: white;
            padding: 1rem 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            font-size: 0.9rem;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .selection-hint.show {
            opacity: 1;
        }

        /* ============================================
           MANAGER TAB - SPECIFIC STYLES
           ============================================ */
        .manager-sidebar {
            padding: 1.5rem;
        }

        .manager-section {
            margin-bottom: 2rem;
        }

        .manager-section h3 {
            font-size: 1rem;
            color: #303030;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e0e0e0;
        }

        /* ============================================
           SELLER TAB STYLES
           ============================================ */
        .seller-sidebar {
            padding: 1.5rem;
        }

        .seller-section {
            margin-bottom: 2rem;
        }

        .seller-section h3 {
            font-size: 1rem;
            color: #303030;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e0e0e0;
        }

        .available-spots-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: calc(100vh - 250px);
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .available-spots-list::-webkit-scrollbar {
            width: 6px;
        }

        .available-spots-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .available-spots-list::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }

        .available-spots-list::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .available-spot-item {
            background: #f8f9fa;
            padding: 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid #e0e0e0;
            font-weight: 600;
            font-size: 0.9rem;
            color: #303030;
        }

        .available-spot-item:hover {
            background: #e5e7eb;
            transform: translateX(2px);
        }

        .available-spot-item.selected {
            background: #fee2e2;
            border-color: #ef4444;
            color: #dc2626;
        }

        .vendors-list-manager {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .vendors-list-manager::-webkit-scrollbar {
            width: 6px;
        }

        .vendors-list-manager::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .vendors-list-manager::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }

        .vendors-list-manager::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .vendor-item {
            background: #f8f9fa;
            padding: 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid #e0e0e0;
            border-left: 3px solid #999;
            border-right: 3px solid #999;
        }

        .vendor-item:hover {
            background: #e5e7eb;
            transform: translateX(2px);
        }

        .vendor-item.expanded {
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .vendor-item-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .vendor-item-name {
            font-weight: 600;
            font-size: 0.9rem;
            color: #303030;
            flex: 1;
        }

        .vendor-item-count {
            font-size: 0.8rem;
            color: #666;
            margin-top: 0.3rem;
            padding-left: 1.2rem;
        }

        .vendor-item-details {
            display: none;
            margin-top: 0.8rem;
            padding-top: 0.8rem;
            border-top: 1px solid #e0e0e0;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        .vendor-item.expanded .vendor-item-details {
            display: block;
        }

        .vendor-detail-row {
            margin-bottom: 0.4rem;
        }

        .vendor-detail-label {
            font-weight: 600;
            color: #666;
        }

        .vendor-spots-list {
            margin-top: 0.5rem;
            color: #303030;
            word-wrap: break-word;
        }

        .stats-compact {
            display: flex;
            gap: 0.8rem;
            justify-content: space-between;
        }

        .stat-compact-item {
            flex: 1;
            background: #f8f9fa;
            padding: 0.8rem;
            border-radius: 6px;
            text-align: center;
            border-left: 3px solid #303030;
            min-height: 90px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .stat-compact-label {
            font-size: 0.7rem;
            color: #666;
            margin-bottom: 0.3rem;
            text-transform: uppercase;
            font-weight: 500;
        }

        .stat-compact-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #333;
        }

        .stat-compact-subvalue {
            font-size: 0.75rem;
            color: #10b981;
            font-weight: 600;
            margin-top: 0.3rem;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 0.8rem;
            border-left: 4px solid #303030;
        }

        .stat-card h4 {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 0.5rem;
        }

        .stat-card .value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
        }

        .manager-parking-spot {
            position: absolute;
            border: 1px solid #303030;
            background: transparent;
            cursor: pointer;
            pointer-events: all;
            transition: all 0.2s;
        }

        .manager-parking-spot:hover {
            border-color: #ef4444 !important;
            z-index: 10;
        }

        /* Vendor color will be applied via inline style as background */
        .manager-parking-spot[data-vendor-color] {
            /* Background color will be set dynamically per vendor */
        }

        .manager-parking-spot.occupied {
            /* Keep border color, background from vendor */
            border-color: #303030;
        }

        .manager-parking-spot.reserved {
            /* Keep border color, background from vendor */
            border-color: #303030;
        }

        .manager-parking-spot.available {
            /* Keep border color, transparent background */
            border-color: #303030;
            background: transparent;
        }

        .manager-parking-spot.selected {
            border-color: #ef4444 !important;
            z-index: 100;
        }

        /* ============================================
           SELLER PARKING SPOTS
           ============================================ */
        .seller-parking-spot {
            position: absolute;
            cursor: pointer;
            pointer-events: all;
            transition: all 0.2s;
        }

        .seller-parking-spot:hover {
            opacity: 0.9;
            z-index: 10;
        }

        .manager-parking-spot.vendor-highlighted {
            box-shadow: 0 0 0 3px #ff6600, 0 0 8px 2px rgba(255, 102, 0, 0.6);
            z-index: 50;
        }

        /* Status legend */
        .status-legend {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid;
        }

        .legend-color.available {
            background: rgba(16, 185, 129, 0.2);
            border-color: #10b981;
        }

        .legend-color.occupied {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
        }

        .legend-color.reserved {
            background: rgba(245, 158, 11, 0.2);
            border-color: #f59e0b;
        }

        /* ============================================
           MODALS
           ============================================ */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .modal h2 {
            color: #303030;
            margin-bottom: 1rem;
        }

        .modal textarea {
            width: 100%;
            min-height: 300px;
            padding: 1rem;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }

        .modal-buttons {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }

        /* ============================================
           UTILITY CLASSES
           ============================================ */
        .hidden {
            display: none !important;
        }

        /* Instructions box */
        .instruction-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 12px;
            padding: 2rem;
            max-width: 500px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            z-index: 9999;
        }

        .instruction-box h3 {
            color: #303030;
            margin-bottom: 1rem;
        }

        .instruction-box ul {
            list-style-position: inside;
            line-height: 1.8;
            margin-bottom: 1rem;
        }

        .instruction-box button {
            width: 100%;
        }

        /* ============================================
           BACKUP/RESTORE CONTROLS
           ============================================ */
        .backup-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .btn-backup {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            padding: 0.6rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }

        .btn-backup:hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
        }

        .btn-restore {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            padding: 0.6rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }

        .btn-restore:hover {
            background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
        }

        .auto-backup-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.8rem;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .auto-backup-indicator:hover {
            background: rgba(255,255,255,0.15);
        }

        .auto-backup-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 2s infinite;
        }

        .auto-backup-dot.disabled {
            background: #6b7280;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Storage status indicator */
        .storage-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 0.8rem 1.2rem;
            border-radius: 8px;
            font-size: 0.85rem;
            display: none;
            align-items: center;
            gap: 0.5rem;
            z-index: 9999;
            animation: slideIn 0.3s ease-out;
        }

        .storage-status.show {
            display: flex;
        }

        .storage-status.success {
            background: rgba(16, 185, 129, 0.95);
        }

        .storage-status.error {
            background: rgba(239, 68, 68, 0.95);
        }

        @keyframes slideIn {
            from {
                transform: translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <!-- Header with Tabs -->
    <div class="header">
        <div class="header-top">
            <div class="header-left">
                <img src="logo.png" alt="Celtic Park Logo" class="header-logo">
                <div class="header-text">
                    <h1>Celtic Park Piaseczno - Parking Management</h1>
                </div>
            </div>
            <div class="header-controls">
                <div class="backup-controls">
                    <div class="auto-backup-indicator" onclick="app.storage.toggleAutoBackup()" title="Kliknij aby w≈ÇƒÖczyƒá/wy≈ÇƒÖczyƒá auto-backup">
                        <div class="auto-backup-dot" id="autoBackupDot"></div>
                        <span id="autoBackupStatus">Auto-backup: ON</span>
                    </div>
                    <button class="btn btn-backup" onclick="app.storage.downloadBackup()">
                        üíæ Pobierz Backup
                    </button>
                    <button class="btn btn-restore" onclick="app.storage.uploadBackup()">
                        üì§ Przywr√≥ƒá z Backupu
                    </button>
                </div>
                <button class="btn btn-primary" onclick="app.ui.toggleInstructions()">üìñ Pomoc</button>
            </div>
        </div>
        <div class="tab-navigation">
            <div class="tab-group-left">
                <button class="tab-btn active" onclick="app.ui.switchTab('manager')">üìä Manager</button>
                <button class="tab-btn" onclick="app.ui.switchTab('seller')">üè∑Ô∏è Sprzeda≈º</button>
            </div>
            <div class="tab-group-right">
                <button class="tab-btn" onclick="app.ui.switchTab('designer')">üé® Designer</button>
                <button class="tab-btn" onclick="app.ui.switchTab('vendors')">üë• Vendorzy</button>
                <button class="tab-btn" onclick="app.ui.switchTab('prices')">üí∞ Cennik</button>
            </div>
        </div>
    </div>

    <!-- MANAGER TAB -->
    <div id="managerTab" class="tab-content active">
        <div class="sidebar manager-sidebar">
            <div class="manager-section">
                <h3>üìà Statystyki</h3>
                <div class="stats-compact">
                    <div class="stat-compact-item">
                        <div class="stat-compact-label">Razem</div>
                        <div class="stat-compact-value" id="totalSpots">0</div>
                        <div class="stat-compact-subvalue" id="totalValue">0 PLN</div>
                    </div>
                    <div class="stat-compact-item">
                        <div class="stat-compact-label">Wolne</div>
                        <div class="stat-compact-value" id="availableSpots">0</div>
                        <div class="stat-compact-subvalue" id="availableValue">0 PLN</div>
                    </div>
                    <div class="stat-compact-item">
                        <div class="stat-compact-label">Zajƒôte</div>
                        <div class="stat-compact-value" id="occupiedSpots">0</div>
                        <div class="stat-compact-subvalue" id="occupiedValue">0 PLN</div>
                    </div>
                </div>
            </div>

            <div class="manager-section" id="spotDetailsSection" style="display: none;">
                <h3>‚ÑπÔ∏è Szczeg√≥≈Çy miejsca</h3>
                <div id="spotDetails"></div>
            </div>

            <div class="manager-section" id="vendorsListSection">
                <h3>üë• Vendorzy</h3>
                <div id="vendorsList" class="vendors-list-manager">
                    <!-- Vendors will be rendered here -->
                </div>
            </div>
        </div>

        <div class="map-area">
            <div class="map-toolbar">
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="app.ui.zoomOut()">‚àí</button>
                    <input type="text" class="zoom-level" id="zoomLevelManager" value="100%" onkeypress="app.ui.handleZoomInput(event, 'manager')">
                    <button class="zoom-btn" onclick="app.ui.zoomIn()">+</button>
                    <button class="zoom-btn" onclick="app.ui.zoomReset()">‚ü≤</button>
                </div>
            </div>
            
            <div class="map-container" id="mapContainerManager">
                <div class="map-scale-container" id="mapScaleContainerManager">
                    <div class="map-wrapper" id="mapWrapperManager">
                        <img src="parking_clean.png" alt="Parking Map Clean" class="map-image" id="mapImageManager">
                        <div class="spots-overlay" id="spotsOverlayManager"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- SELLER TAB -->
    <div id="sellerTab" class="tab-content">
        <div class="sidebar seller-sidebar">
            <div class="seller-section">
                <h3>üìã Dostƒôpne miejsca</h3>
                <div id="availableSpotsList" class="available-spots-list">
                    <!-- Available spots will be rendered here -->
                </div>
            </div>
        </div>

        <div class="map-area">
            <div class="map-toolbar">
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="app.ui.zoomOut()">‚àí</button>
                    <input type="text" class="zoom-level" id="zoomLevelSeller" value="100%" onkeypress="app.ui.handleZoomInput(event, 'seller')">
                    <button class="zoom-btn" onclick="app.ui.zoomIn()">+</button>
                    <button class="zoom-btn" onclick="app.ui.zoomReset()">‚ü≤</button>
                </div>
            </div>
            
            <div class="map-container" id="mapContainerSeller">
                <div class="map-scale-container" id="mapScaleContainerSeller">
                    <div class="map-wrapper" id="mapWrapperSeller">
                        <img src="parking_clean.png" alt="Parking Map Clean" class="map-image" id="mapImageSeller">
                        <div class="spots-overlay" id="spotsOverlaySeller"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- VENDORS TAB -->
    <div id="vendorsTab" class="tab-content">
        <div class="vendors-container">
            <div class="vendors-header">
                <h2>üë• Vendorzy</h2>
                <button class="btn btn-success" onclick="app.vendors.openAddModal()">‚ûï Dodaj Vendora</button>
            </div>

            <div class="vendors-table-container">
                <div class="vendors-table-wrapper">
                    <table class="vendors-table" id="vendorsTable">
                        <thead>
                            <tr>
                                <th class="sortable" style="width: 5%;" onclick="app.vendors.sortBy('id')">ID</th>
                                <th class="sortable" style="width: 20%;" onclick="app.vendors.sortBy('name')">Nazwa</th>
                                <th style="width: 18%;">Osoba kontaktowa</th>
                                <th style="width: 18%;">Email</th>
                                <th style="width: 12%;">Telefon</th>
                                <th style="width: 12%;">Ilo≈õƒá miejsc</th>
                                <th style="width: 15%;">Akcje</th>
                            </tr>
                        </thead>
                        <tbody id="vendorsTableBody">
                            <!-- Vendors will be rendered here -->
                        </tbody>
                    </table>
                    <div id="vendorsEmptyState" class="empty-state">
                        <div class="empty-state-icon">üë•</div>
                        <div class="empty-state-text">Brak vendor√≥w</div>
                        <div class="empty-state-hint">Kliknij "Dodaj Vendora" aby dodaƒá pierwszego najemcƒô</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- DESIGNER TAB -->
    <div id="designerTab" class="tab-content">
        <div class="sidebar">
            <div class="sidebar-header">
                <h2>üé® Designer Miejsc</h2>
            </div>

            <div class="spot-list-controls">
                <div class="add-spot-form">
                    <input type="text" id="newSpotNumber" placeholder="Numer miejsca (np. 001, 123A)" />
                    <button onclick="app.designer.addSpot()">‚ûï</button>
                </div>
            </div>

            <div class="stats-bar" id="statsBar">
                <span id="statsText">0 miejsc dodanych, 0 zmapowanych</span>
            </div>

            <div class="control-panel" id="controlPanel">
                <div class="control-group">
                    <label>Szeroko≈õƒá (px)</label>
                    <div class="spinner-control">
                        <button onclick="app.designer.adjustWidth(-1)">‚àí</button>
                        <input type="number" id="widthValue" min="5" max="100" onchange="app.designer.updateDimensions()">
                        <button onclick="app.designer.adjustWidth(1)">+</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Wysoko≈õƒá (px)</label>
                    <div class="spinner-control">
                        <button onclick="app.designer.adjustHeight(-1)">‚àí</button>
                        <input type="number" id="heightValue" min="5" max="100" onchange="app.designer.updateDimensions()">
                        <button onclick="app.designer.adjustHeight(1)">+</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Rotacja (stopnie)</label>
                    <div class="spinner-control">
                        <button onclick="app.designer.adjustRotation(-15)">‚àí</button>
                        <input type="number" id="rotationValue" min="0" max="360" step="15" onchange="app.designer.updateDimensions()">
                        <button onclick="app.designer.adjustRotation(15)">+</button>
                    </div>
                </div>
            </div>

            <div class="spots-list" id="spotsList"></div>
        </div>

        <div class="map-area">
            <div class="map-toolbar">
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="app.ui.zoomOut()">‚àí</button>
                    <input type="text" class="zoom-level" id="zoomLevel" value="100%" onkeypress="app.ui.handleZoomInput(event, 'designer')">
                    <button class="zoom-btn" onclick="app.ui.zoomIn()">+</button>
                    <button class="zoom-btn" onclick="app.ui.zoomReset()">‚ü≤</button>
                </div>
                <button class="btn btn-secondary" onclick="app.designer.loadSampleData()">üìã Wczytaj Przyk≈Çadowe Miejsca</button>
            </div>
            
            <div class="map-container" id="mapContainer">
                <div class="map-scale-container" id="mapScaleContainer">
                    <div class="map-wrapper" id="mapWrapper">
                        <img src="parking_map.png" alt="Parking Map" class="map-image" id="mapImage">
                        <div class="spots-overlay" id="spotsOverlay"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="selection-hint" id="selectionHint">
            üëÜ Wska≈º kursorem, gdzie poczƒÖtkowo umie≈õciƒá obiekt, a nastƒôpnie dopasuj go do lokalizacji miejsca parkingowego
        </div>
    </div>

    <!-- PRICES TAB -->
    <div id="pricesTab" class="tab-content">
        <div class="prices-container">
            <div class="prices-header">
                <h2>üí∞ Cennik</h2>
                <button class="btn btn-success" onclick="app.prices.openAddModal()">‚ûï Dodaj Cenƒô</button>
            </div>

            <div class="prices-table-container">
                <div class="prices-table-wrapper">
                    <table class="prices-table" id="pricesTable">
                        <thead>
                            <tr>
                                <th style="width: 10%;">ID</th>
                                <th style="width: 40%;">Nazwa</th>
                                <th style="width: 20%;">Cena (PLN)</th>
                                <th style="width: 15%;">Ilo≈õƒá miejsc</th>
                                <th style="width: 15%;">Akcje</th>
                            </tr>
                        </thead>
                        <tbody id="pricesTableBody">
                            <!-- Prices will be rendered here -->
                        </tbody>
                    </table>
                    <div id="pricesEmptyState" class="empty-state">
                        <div class="empty-state-icon">üí∞</div>
                        <div class="empty-state-text">Brak cen</div>
                        <div class="empty-state-hint">Kliknij "Dodaj Cenƒô" aby dodaƒá pierwszy typ miejsca z cenƒÖ</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file inputs -->
    <input type="file" id="jsonFileInput" accept=".json" style="display: none;" onchange="State.handleFileImport(event)">
    <input type="file" id="backupFileInput" accept=".json" style="display: none;" onchange="app.storage.handleBackupRestore(event)">

    <!-- Storage status indicator -->
    <div id="storageStatus" class="storage-status">
        <span id="storageStatusText"></span>
    </div>

    <!-- Export Modal -->
    <div class="modal-overlay" id="exportModal">
        <div class="modal">
            <h2>üìã Wyeksportowane Wsp√≥≈Çrzƒôdne</h2>
            <textarea id="exportTextarea" readonly></textarea>
            <div class="modal-buttons">
                <button class="btn btn-secondary" onclick="app.ui.closeExportModal()">Zamknij</button>
                <button class="btn btn-success" onclick="app.ui.copyToClipboard()">üìã Kopiuj</button>
            </div>
        </div>
    </div>

    <!-- Vendor Modal -->
    <div class="modal-overlay" id="vendorModal">
        <div class="modal vendor-modal-content">
            <h2 id="vendorModalTitle">Dodaj Vendora</h2>
            <form id="vendorForm">
                <div class="form-group">
                    <label>Nazwa <span class="required">*</span></label>
                    <input type="text" id="vendorName" name="name" required>
                    <div class="form-error" id="vendorNameError">Vendor o tej nazwie ju≈º istnieje</div>
                </div>
                <div class="form-group">
                    <label>Osoba kontaktowa</label>
                    <input type="text" id="vendorContact" name="contact">
                </div>
                <div class="form-group">
                    <label>Email</label>
                    <input type="email" id="vendorEmail" name="email">
                </div>
                <div class="form-group">
                    <label>Telefon</label>
                    <input type="tel" id="vendorPhone" name="phone">
                </div>
                <div class="modal-buttons">
                    <button type="button" class="btn btn-secondary" onclick="app.vendors.closeModal()">Anuluj</button>
                    <button type="button" id="saveAndAddAnotherBtn" class="btn btn-warning" onclick="app.vendors.saveAndAddAnother()">Zapisz i dodaj kolejny</button>
                    <button type="submit" class="btn btn-success">Zapisz</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Price Modal -->
    <div class="modal-overlay" id="priceModal">
        <div class="modal price-modal-content">
            <h2 id="priceModalTitle">Dodaj Cenƒô</h2>
            <form id="priceForm">
                <div class="form-group">
                    <label>Nazwa <span class="required">*</span></label>
                    <input type="text" id="priceName" name="name" required>
                    <div class="form-error" id="priceNameError">Cena o tej nazwie ju≈º istnieje</div>
                </div>
                <div class="form-group">
                    <label>Cena (PLN) <span class="required">*</span></label>
                    <input type="number" id="priceValue" name="price" step="0.01" min="0.01" required>
                    <div class="form-error" id="priceValueError">Cena musi byƒá dodatnia</div>
                </div>
                <div class="modal-buttons">
                    <button type="button" class="btn btn-secondary" onclick="app.prices.closeModal()">Anuluj</button>
                    <button type="submit" class="btn btn-success">Zapisz</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Instructions Modal -->
    <div class="instruction-box hidden" id="instructionBox">
        <h3>üìñ Jak u≈ºywaƒá</h3>
        <ul>
            <li>Dodaj miejsca u≈ºywajƒÖc formularza lub za≈Çaduj przyk≈Çadowe dane</li>
            <li>Wybierz miejsce z listy</li>
            <li>Wska≈º kursorem, gdzie poczƒÖtkowo umie≈õciƒá obiekt, a nastƒôpnie dopasuj go do lokalizacji miejsca parkingowego</li>
            <li>U≈ºyj strza≈Çek na klawiaturze do precyzyjnego ustawienia pozycji (Shift = szybciej)</li>
            <li>Dostosuj rozmiar i rotacjƒô za pomocƒÖ kontrolek</li>
            <li>Zapisz swojƒÖ pracƒô u≈ºywajƒÖc przycisku Zapisz</li>
        </ul>
        <button class="btn btn-primary" onclick="app.ui.toggleInstructions()">Rozumiem!</button>
    </div>

    <script>
        // ============================================
        // APPLICATION CORE - Modular Architecture
        // ============================================

        const ParkingApp = (function() {
            'use strict';

            // ============================================
            // CONSTANTS
            // ============================================
            const CONSTANTS = {
                DEFAULT_SPOT_WIDTH: 6,
                DEFAULT_SPOT_HEIGHT: 12,
                DEFAULT_ROTATION: 270,
                MIN_DIMENSION: 5,
                MAX_DIMENSION: 100,
                KEYBOARD_STEP_NORMAL: 1,
                KEYBOARD_STEP_FAST: 5,
                MIN_ZOOM: 1,
                MAX_ZOOM: 10,
                ZOOM_STEP: 1
            };

            // ============================================
            // INDEXEDDB STORAGE MODULE
            // ============================================
            const StorageDB = {
                dbName: 'CelticParkDB',
                dbVersion: 1,
                db: null,
                
                // Auto-backup settings
                autoBackupEnabled: true,
                autoBackupInterval: 10 * 60 * 1000, // 10 minutes
                autoBackupTimer: null,
                changeCounter: 0,
                
                // Initialize IndexedDB
                async init() {
                    try {
                        // Check if auto-backup preference is stored
                        const autoBackupPref = localStorage.getItem('autoBackupEnabled');
                        if (autoBackupPref !== null) {
                            this.autoBackupEnabled = autoBackupPref === 'true';
                        }
                        
                        this.db = await this.openDB();
                        
                        // Migrate from localStorage if first time
                        await this.migrateFromLocalStorage();
                        
                        // Start auto-backup timer
                        this.startAutoBackup();
                        
                        // Update UI
                        this.updateAutoBackupUI();
                        
                        console.log('‚úÖ IndexedDB initialized successfully');
                        return true;
                    } catch (error) {
                        console.error('‚ùå IndexedDB initialization failed:', error);
                        this.showStatus('Ostrze≈ºenie: U≈ºywam localStorage jako fallback', 'error');
                        return false;
                    }
                },
                
                // Open IndexedDB connection
                openDB() {
                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open(this.dbName, this.dbVersion);
                        
                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => resolve(request.result);
                        
                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            
                            // Create object stores
                            if (!db.objectStoreNames.contains('spots')) {
                                db.createObjectStore('spots', { keyPath: 'id' });
                            }
                            if (!db.objectStoreNames.contains('vendors')) {
                                db.createObjectStore('vendors', { keyPath: 'id' });
                            }
                            if (!db.objectStoreNames.contains('prices')) {
                                db.createObjectStore('prices', { keyPath: 'id' });
                            }
                            if (!db.objectStoreNames.contains('metadata')) {
                                db.createObjectStore('metadata', { keyPath: 'key' });
                            }
                        };
                    });
                },
                
                // Migrate data from localStorage to IndexedDB (one-time)
                async migrateFromLocalStorage() {
                    try {
                        const migrated = await this.getMetadata('migrated');
                        if (migrated && migrated.value === true) {
                            console.log('‚úÖ Data already migrated');
                            return;
                        }
                        
                        // Check if localStorage has data
                        const spotsJSON = localStorage.getItem('parkingSpots');
                        const vendorsJSON = localStorage.getItem('parkingVendors');
                        const pricesJSON = localStorage.getItem('parkingPrices');
                        
                        if (!spotsJSON && !vendorsJSON && !pricesJSON) {
                            console.log('‚ÑπÔ∏è No localStorage data to migrate');
                            await this.saveMetadata('migrated', true);
                            return;
                        }
                        
                        console.log('üîÑ Migrating data from localStorage to IndexedDB...');
                        
                        // Migrate spots
                        if (spotsJSON) {
                            const spots = JSON.parse(spotsJSON);
                            for (const [key, spot] of Object.entries(spots)) {
                                await this.saveSpot(spot);
                            }
                        }
                        
                        // Migrate vendors
                        if (vendorsJSON) {
                            const vendors = JSON.parse(vendorsJSON);
                            for (const vendor of vendors) {
                                await this.saveVendor(vendor);
                            }
                        }
                        
                        // Migrate prices
                        if (pricesJSON) {
                            const prices = JSON.parse(pricesJSON);
                            for (const price of prices) {
                                await this.savePrice(price);
                            }
                        }
                        
                        await this.saveMetadata('migrated', true);
                        await this.saveMetadata('migrationDate', new Date().toISOString());
                        
                        console.log('‚úÖ Migration completed successfully');
                        this.showStatus('Dane zosta≈Çy zmigrowane do nowego systemu przechowywania', 'success');
                        
                        // Keep localStorage as backup for now
                        // Don't delete it immediately - user can do manual cleanup
                        
                    } catch (error) {
                        console.error('‚ùå Migration failed:', error);
                        throw error;
                    }
                },
                
                // Generic transaction helper
                async transaction(storeName, mode, callback) {
                    if (!this.db) {
                        // Fallback to localStorage
                        throw new Error('IndexedDB not available');
                    }
                    
                    return new Promise((resolve, reject) => {
                        const tx = this.db.transaction(storeName, mode);
                        const store = tx.objectStore(storeName);
                        const request = callback(store);
                        
                        if (request) {
                            request.onsuccess = () => resolve(request.result);
                            request.onerror = () => reject(request.error);
                        } else {
                            tx.oncomplete = () => resolve();
                            tx.onerror = () => reject(tx.error);
                        }
                    });
                },
                
                // Spots operations
                async getAllSpots() {
                    try {
                        const spotsArray = await this.transaction('spots', 'readonly', 
                            (store) => store.getAll()
                        );
                        
                        // Convert array to object keyed by id
                        const spotsObj = {};
                        spotsArray.forEach(spot => {
                            spotsObj[spot.id] = spot;
                        });
                        return spotsObj;
                    } catch (error) {
                        console.error('Error getting spots:', error);
                        // Fallback to localStorage
                        const data = localStorage.getItem('parkingSpots');
                        return data ? JSON.parse(data) : {};
                    }
                },
                
                async saveSpot(spot) {
                    try {
                        await this.transaction('spots', 'readwrite', 
                            (store) => store.put(spot)
                        );
                        this.incrementChangeCounter();
                    } catch (error) {
                        console.error('Error saving spot:', error);
                        // Fallback to localStorage
                        const spots = JSON.parse(localStorage.getItem('parkingSpots') || '{}');
                        spots[spot.id] = spot;
                        localStorage.setItem('parkingSpots', JSON.stringify(spots));
                    }
                },
                
                async deleteSpot(id) {
                    try {
                        await this.transaction('spots', 'readwrite', 
                            (store) => store.delete(id)
                        );
                        this.incrementChangeCounter();
                    } catch (error) {
                        console.error('Error deleting spot:', error);
                    }
                },
                
                // Vendors operations
                async getAllVendors() {
                    try {
                        return await this.transaction('vendors', 'readonly', 
                            (store) => store.getAll()
                        );
                    } catch (error) {
                        console.error('Error getting vendors:', error);
                        const data = localStorage.getItem('parkingVendors');
                        return data ? JSON.parse(data) : [];
                    }
                },
                
                async saveVendor(vendor) {
                    try {
                        await this.transaction('vendors', 'readwrite', 
                            (store) => store.put(vendor)
                        );
                        this.incrementChangeCounter();
                    } catch (error) {
                        console.error('Error saving vendor:', error);
                        const vendors = JSON.parse(localStorage.getItem('parkingVendors') || '[]');
                        const index = vendors.findIndex(v => v.id === vendor.id);
                        if (index >= 0) {
                            vendors[index] = vendor;
                        } else {
                            vendors.push(vendor);
                        }
                        localStorage.setItem('parkingVendors', JSON.stringify(vendors));
                    }
                },
                
                async deleteVendor(id) {
                    try {
                        await this.transaction('vendors', 'readwrite', 
                            (store) => store.delete(id)
                        );
                        this.incrementChangeCounter();
                    } catch (error) {
                        console.error('Error deleting vendor:', error);
                    }
                },
                
                // Prices operations
                async getAllPrices() {
                    try {
                        return await this.transaction('prices', 'readonly', 
                            (store) => store.getAll()
                        );
                    } catch (error) {
                        console.error('Error getting prices:', error);
                        const data = localStorage.getItem('parkingPrices');
                        return data ? JSON.parse(data) : [];
                    }
                },
                
                async savePrice(price) {
                    try {
                        await this.transaction('prices', 'readwrite', 
                            (store) => store.put(price)
                        );
                        this.incrementChangeCounter();
                    } catch (error) {
                        console.error('Error saving price:', error);
                        const prices = JSON.parse(localStorage.getItem('parkingPrices') || '[]');
                        const index = prices.findIndex(p => p.id === price.id);
                        if (index >= 0) {
                            prices[index] = price;
                        } else {
                            prices.push(price);
                        }
                        localStorage.setItem('parkingPrices', JSON.stringify(prices));
                    }
                },
                
                async deletePrice(id) {
                    try {
                        await this.transaction('prices', 'readwrite', 
                            (store) => store.delete(id)
                        );
                        this.incrementChangeCounter();
                    } catch (error) {
                        console.error('Error deleting price:', error);
                    }
                },
                
                // Metadata operations
                async saveMetadata(key, value) {
                    try {
                        await this.transaction('metadata', 'readwrite', 
                            (store) => store.put({ key, value })
                        );
                    } catch (error) {
                        console.error('Error saving metadata:', error);
                    }
                },
                
                async getMetadata(key) {
                    try {
                        return await this.transaction('metadata', 'readonly', 
                            (store) => store.get(key)
                        );
                    } catch (error) {
                        console.error('Error getting metadata:', error);
                        return null;
                    }
                },
                
                // Change counter for auto-backup
                incrementChangeCounter() {
                    this.changeCounter++;
                },
                
                resetChangeCounter() {
                    this.changeCounter = 0;
                },
                
                // Auto-backup functionality
                startAutoBackup() {
                    if (!this.autoBackupEnabled) return;
                    
                    if (this.autoBackupTimer) {
                        clearInterval(this.autoBackupTimer);
                    }
                    
                    this.autoBackupTimer = setInterval(() => {
                        if (this.changeCounter > 0) {
                            this.performAutoBackup();
                        }
                    }, this.autoBackupInterval);
                    
                    console.log('‚úÖ Auto-backup started (every 10 minutes)');
                },
                
                stopAutoBackup() {
                    if (this.autoBackupTimer) {
                        clearInterval(this.autoBackupTimer);
                        this.autoBackupTimer = null;
                    }
                    console.log('‚è∏Ô∏è Auto-backup stopped');
                },
                
                async performAutoBackup() {
                    try {
                        const backup = await this.createBackup();
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                        const filename = `celtic-park-auto-backup-${timestamp}.json`;
                        
                        this.downloadJSON(backup, filename);
                        this.resetChangeCounter();
                        
                        this.showStatus(`Auto-backup zapisany: ${filename}`, 'success');
                        console.log('‚úÖ Auto-backup completed');
                    } catch (error) {
                        console.error('‚ùå Auto-backup failed:', error);
                    }
                },
                
                toggleAutoBackup() {
                    this.autoBackupEnabled = !this.autoBackupEnabled;
                    localStorage.setItem('autoBackupEnabled', this.autoBackupEnabled.toString());
                    
                    if (this.autoBackupEnabled) {
                        this.startAutoBackup();
                        this.showStatus('Auto-backup w≈ÇƒÖczony (co 10 minut)', 'success');
                    } else {
                        this.stopAutoBackup();
                        this.showStatus('Auto-backup wy≈ÇƒÖczony', 'success');
                    }
                    
                    this.updateAutoBackupUI();
                },
                
                updateAutoBackupUI() {
                    const statusText = document.getElementById('autoBackupStatus');
                    const dot = document.getElementById('autoBackupDot');
                    
                    if (statusText && dot) {
                        statusText.textContent = this.autoBackupEnabled ? 'Auto-backup: ON' : 'Auto-backup: OFF';
                        dot.classList.toggle('disabled', !this.autoBackupEnabled);
                    }
                },
                
                // Backup/Restore functionality
                async createBackup() {
                    const spots = await this.getAllSpots();
                    const vendors = await this.getAllVendors();
                    const prices = await this.getAllPrices();
                    
                    // Calculate statistics
                    const spotsArray = Object.values(spots);
                    const totalSpots = spotsArray.length;
                    const mappedSpots = spotsArray.filter(s => s.positioned).length;
                    const assignedSpots = spotsArray.filter(s => s.vendorId).length;
                    
                    return {
                        version: '2.0',
                        timestamp: new Date().toISOString(),
                        appVersion: 'MVP 2.0 - Enhanced Storage',
                        databases: {
                            spots,
                            vendors,
                            prices
                        },
                        metadata: {
                            totalSpots,
                            mappedSpots,
                            assignedSpots,
                            totalVendors: vendors.length,
                            totalPrices: prices.length
                        }
                    };
                },
                
                async downloadBackup() {
                    try {
                        const backup = await this.createBackup();
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                        const filename = `celtic-park-backup-${timestamp}.json`;
                        
                        this.downloadJSON(backup, filename);
                        this.showStatus(`Backup zapisany: ${filename}`, 'success');
                    } catch (error) {
                        console.error('‚ùå Backup download failed:', error);
                        this.showStatus('B≈ÇƒÖd podczas tworzenia backupu', 'error');
                    }
                },
                
                uploadBackup() {
                    document.getElementById('backupFileInput').click();
                },
                
                async handleBackupRestore(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    // Confirm with user
                    if (!confirm('‚ö†Ô∏è UWAGA!\n\nPrzywr√≥cenie backupu USUNIE wszystkie obecne dane i zastƒÖpi je danymi z pliku backup.\n\nCzy na pewno chcesz kontynuowaƒá?')) {
                        event.target.value = '';
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const backup = JSON.parse(e.target.result);
                            
                            // Validate backup structure
                            if (!backup.databases || !backup.databases.spots || 
                                !backup.databases.vendors || !backup.databases.prices) {
                                throw new Error('Nieprawid≈Çowa struktura pliku backup');
                            }
                            
                            // Show progress
                            this.showStatus('Przywracanie danych...', 'success');
                            
                            // Clear all existing data
                            await this.clearAllData();
                            
                            // Restore spots
                            for (const [key, spot] of Object.entries(backup.databases.spots)) {
                                await this.saveSpot(spot);
                            }
                            
                            // Restore vendors
                            for (const vendor of backup.databases.vendors) {
                                await this.saveVendor(vendor);
                            }
                            
                            // Restore prices
                            for (const price of backup.databases.prices) {
                                await this.savePrice(price);
                            }
                            
                            // Reload the application
                            this.showStatus('Backup przywr√≥cony pomy≈õlnie! Od≈õwie≈ºanie...', 'success');
                            
                            setTimeout(() => {
                                window.location.reload();
                            }, 1500);
                            
                        } catch (error) {
                            console.error('‚ùå Backup restore failed:', error);
                            this.showStatus('B≈ÇƒÖd podczas przywracania backupu: ' + error.message, 'error');
                        }
                        
                        event.target.value = '';
                    };
                    
                    reader.readAsText(file);
                },
                
                async clearAllData() {
                    try {
                        // Clear IndexedDB
                        const stores = ['spots', 'vendors', 'prices'];
                        for (const storeName of stores) {
                            await this.transaction(storeName, 'readwrite', 
                                (store) => store.clear()
                            );
                        }
                        
                        // Also clear localStorage backup
                        localStorage.removeItem('parkingSpots');
                        localStorage.removeItem('parkingVendors');
                        localStorage.removeItem('parkingPrices');
                        
                        console.log('‚úÖ All data cleared');
                    } catch (error) {
                        console.error('‚ùå Error clearing data:', error);
                        throw error;
                    }
                },
                
                // Helper: Download JSON file
                downloadJSON(data, filename) {
                    const dataStr = JSON.stringify(data, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(dataBlob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    link.click();
                    URL.revokeObjectURL(url);
                },
                
                // Helper: Show status message
                showStatus(message, type = 'success') {
                    const statusDiv = document.getElementById('storageStatus');
                    const statusText = document.getElementById('storageStatusText');
                    
                    if (!statusDiv || !statusText) return;
                    
                    statusText.textContent = message;
                    statusDiv.className = `storage-status show ${type}`;
                    
                    setTimeout(() => {
                        statusDiv.classList.remove('show');
                    }, 4000);
                }
            };

            // ============================================
            // STATE MANAGEMENT
            // ============================================
            const State = {
                // Data
                spots: {},
                selectedSpot: null,
                currentTab: 'manager',
                
                // Vendors data
                vendors: [],
                nextVendorId: 1,
                editingVendorId: null,
                vendorSortColumn: null,  // 'id' or 'name'
                vendorSortDirection: 'asc',  // 'asc' or 'desc'
                
                // Prices data
                prices: [],
                nextPriceId: 1,
                editingPriceId: null,
                
                // UI State - separate zoom for each tab
                designerZoom: 1,
                managerZoom: 1,
                sellerZoom: 1,
                
                // Panning state
                isControlPressed: false,
                isPanning: false,
                panStartX: 0,
                panStartY: 0,
                panScrollLeft: 0,
                panScrollTop: 0,
                
                // Drawing state
                isDrawing: false,
                startX: 0,
                startY: 0,
                
                // Dragging state
                isDragging: false,
                dragStartX: 0,
                dragStartY: 0,
                
                // Initialize state
                async init() {
                    // Initialize IndexedDB first
                    await StorageDB.init();
                    
                    // Load vendors from IndexedDB
                    this.vendors = await StorageDB.getAllVendors();
                    this.nextVendorId = Math.max(...this.vendors.map(v => v.id), 0) + 1;
                    
                    // Load prices from IndexedDB
                    this.prices = await StorageDB.getAllPrices();
                    this.nextPriceId = Math.max(...this.prices.map(p => p.id), 0) + 1;
                    
                    // Load spots from IndexedDB
                    this.spots = await StorageDB.getAllSpots();
                },
                
                // Save to IndexedDB
                async saveVendors() {
                    try {
                        // 1. Get all existing vendors from IndexedDB
                        const existingVendors = await StorageDB.getAllVendors();
                        const existingIds = new Set(existingVendors.map(v => v.id));
                        
                        // 2. Get current vendor IDs from State
                        const currentIds = new Set(this.vendors.map(v => v.id));
                        
                        // 3. Find vendors that exist in DB but not in State (orphaned/deleted)
                        const toDelete = [...existingIds].filter(id => !currentIds.has(id));
                        
                        // 4. Delete orphaned vendors from IndexedDB
                        for (const id of toDelete) {
                            await StorageDB.deleteVendor(id);
                        }
                        
                        // 5. Save/update current vendors (PUT will overwrite if exists)
                        for (const vendor of this.vendors) {
                            await StorageDB.saveVendor(vendor);
                        }
                        
                        // 6. Keep localStorage as fallback
                        localStorage.setItem('parkingVendors', JSON.stringify(this.vendors));
                    } catch (error) {
                        console.error('Error saving vendors:', error);
                        // Fallback to localStorage only
                        localStorage.setItem('parkingVendors', JSON.stringify(this.vendors));
                    }
                },
                
                async savePrices() {
                    try {
                        // 1. Get all existing prices from IndexedDB
                        const existingPrices = await StorageDB.getAllPrices();
                        const existingIds = new Set(existingPrices.map(p => p.id));
                        
                        // 2. Get current price IDs from State
                        const currentIds = new Set(this.prices.map(p => p.id));
                        
                        // 3. Find prices that exist in DB but not in State (orphaned/deleted)
                        const toDelete = [...existingIds].filter(id => !currentIds.has(id));
                        
                        // 4. Delete orphaned prices from IndexedDB
                        for (const id of toDelete) {
                            await StorageDB.deletePrice(id);
                        }
                        
                        // 5. Save/update current prices (PUT will overwrite if exists)
                        for (const price of this.prices) {
                            await StorageDB.savePrice(price);
                        }
                        
                        // 6. Keep localStorage as fallback
                        localStorage.setItem('parkingPrices', JSON.stringify(this.prices));
                    } catch (error) {
                        console.error('Error saving prices:', error);
                        // Fallback to localStorage only
                        localStorage.setItem('parkingPrices', JSON.stringify(this.prices));
                    }
                },
                
                async saveSpots() {
                    try {
                        // 1. Get all existing spots from IndexedDB
                        const existingSpotsObj = await StorageDB.getAllSpots();
                        const existingIds = new Set(Object.keys(existingSpotsObj));
                        
                        // 2. Get current spot IDs from State
                        const currentIds = new Set(Object.keys(this.spots));
                        
                        // 3. Find spots that exist in DB but not in State (deleted)
                        const toDelete = [...existingIds].filter(id => !currentIds.has(id));
                        
                        // 4. Delete removed spots from IndexedDB
                        for (const id of toDelete) {
                            await StorageDB.deleteSpot(id);
                        }
                        
                        // 5. Save/update current spots (PUT will overwrite if exists)
                        for (const spot of Object.values(this.spots)) {
                            await StorageDB.saveSpot(spot);
                        }
                        
                        // 6. Keep localStorage as fallback
                        localStorage.setItem('parkingSpots', JSON.stringify(this.spots));
                    } catch (error) {
                        console.error('Error saving spots:', error);
                        // Fallback to localStorage only
                        localStorage.setItem('parkingSpots', JSON.stringify(this.spots));
                    }
                },

                // Get spot by ID
                getSpot(id) {
                    return this.spots[id];
                },

                // Add or update spot
                setSpot(id, spotData) {
                    this.spots[id] = spotData;
                },

                // Delete spot
                async deleteSpot(id) {
                    delete this.spots[id];
                    if (this.selectedSpot === id) {
                        this.selectedSpot = null;
                    }
                    await StorageDB.deleteSpot(id);
                    await this.saveSpots();
                },

                // Get all positioned spots
                getPositionedSpots() {
                    return Object.values(this.spots).filter(s => s.positioned);
                },

                // Get sorted spots
                getSortedSpots() {
                    return Object.values(this.spots).sort((a, b) => {
                        return a.id.localeCompare(b.id, undefined, { numeric: true });
                    });
                },

                // Export to JSON
                exportToJSON() {
                    const positionedSpots = {};
                    const mapImage = document.getElementById('mapImage');
                    
                    Object.keys(this.spots).forEach(key => {
                        if (this.spots[key].positioned) {
                            const spot = this.spots[key];
                            const labelCenterX = spot.x + (spot.width / (mapImage.naturalWidth || mapImage.width)) * 100 / 2;
                            const labelCenterY = spot.y + (spot.height / (mapImage.naturalHeight || mapImage.height)) * 100 / 2;
                            const labelRotation = spot.height > spot.width ? 90 : 0;
                            
                            positionedSpots[key] = {
                                ...spot,
                                label: {
                                    centerX: parseFloat(labelCenterX.toFixed(4)),
                                    centerY: parseFloat(labelCenterY.toFixed(4)),
                                    rotation: labelRotation,
                                    text: spot.id,
                                    fontSize: 5
                                }
                            };
                        }
                    });
                    
                    if (Object.keys(positionedSpots).length === 0) {
                        alert('Brak zmapowanych miejsc do eksportu!');
                        return;
                    }
                    
                    const dataStr = JSON.stringify(positionedSpots, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(dataBlob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = 'parking-spots-' + new Date().toISOString().split('T')[0] + '.json';
                    link.click();
                    URL.revokeObjectURL(url);
                },

                // Import from JSON
                importFromJSON() {
                    document.getElementById('jsonFileInput').click();
                },

                // Handle file import
                handleFileImport(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    if (Object.keys(this.spots).length > 0) {
                        if (!confirm('To zastƒÖpi WSZYSTKIE istniejƒÖce miejsca. Kontynuowaƒá?')) {
                            event.target.value = '';
                            return;
                        }
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const importedData = JSON.parse(e.target.result);
                            
                            if (typeof importedData !== 'object' || importedData === null) {
                                throw new Error('Invalid JSON format');
                            }

                            this.spots = {};
                            this.selectedSpot = null;

                            Object.keys(importedData).forEach(key => {
                                const spot = importedData[key];
                                if (spot.id && spot.hasOwnProperty('x') && spot.hasOwnProperty('y') && 
                                    spot.hasOwnProperty('width') && spot.hasOwnProperty('height') && 
                                    spot.hasOwnProperty('rotation') && spot.hasOwnProperty('positioned')) {
                                    this.spots[key] = spot;
                                }
                            });

                            app.designer.updateUI();
                            app.manager.refreshView();
                            
                            const importedCount = Object.keys(this.spots).length;
                            alert(`Pomy≈õlnie zaimportowano ${importedCount} ${Utils.getPolishPlural(importedCount)}!`);
                            
                        } catch (error) {
                            alert('B≈ÇƒÖd importu pliku: ' + error.message);
                        }
                        
                        event.target.value = '';
                    };

                    reader.readAsText(file);
                }
            };

            // ============================================
            // UTILITY FUNCTIONS
            // ============================================
            const Utils = {
                // Convert pixel coordinates to percentage
                pxToPercent(px, dimension) {
                    return (px / dimension) * 100;
                },

                // Convert percentage to pixel coordinates
                percentToPx(percent, dimension) {
                    return (percent / 100) * dimension;
                },

                // Get image rectangle
                getImageRect(imageId) {
                    const img = document.getElementById(imageId);
                    return img ? img.getBoundingClientRect() : null;
                },

                // Calculate rotated corners of a rectangle
                calculateCorners(spot, imageRect) {
                    const centerX = this.percentToPx(spot.x, imageRect.width) + spot.width / 2;
                    const centerY = this.percentToPx(spot.y, imageRect.height) + spot.height / 2;
                    const halfW = spot.width / 2;
                    const halfH = spot.height / 2;
                    
                    const rad = spot.rotation * Math.PI / 180;
                    const cos = Math.cos(rad);
                    const sin = Math.sin(rad);
                    
                    const corners = [
                        { x: -halfW, y: -halfH },
                        { x: halfW, y: -halfH },
                        { x: halfW, y: halfH },
                        { x: -halfW, y: halfH }
                    ];
                    
                    return corners.map(corner => ({
                        x: (centerX + corner.x * cos - corner.y * sin).toFixed(2),
                        y: (centerY + corner.x * sin + corner.y * cos).toFixed(2)
                    }));
                },
                
                // Generate diverse colors for vendors using golden ratio distribution
                generateVendorColor() {
                    // Count how many vendors already have colors assigned
                    const vendorsWithColors = State.vendors.filter(v => v.color).length;
                    
                    // Golden ratio for maximally distributed hues
                    const goldenRatioConjugate = 0.618033988749895;
                    
                    // Calculate hue based on vendor index using golden ratio
                    // This ensures maximum separation between consecutive colors
                    const hue = Math.floor((vendorsWithColors * goldenRatioConjugate * 360) % 360);
                    
                    // Vary saturation and lightness slightly for additional diversity
                    // Use vendor count to cycle through variations
                    const satVariation = (vendorsWithColors % 4) * 7; // 0, 7, 14, 21
                    const lightVariation = (Math.floor(vendorsWithColors / 4) % 3) * 5; // 0, 5, 10
                    
                    const saturation = 65 + satVariation; // 65-86%
                    const lightness = 50 + lightVariation; // 50-60%
                    
                    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                },
                
                // Get or assign color to vendor
                getVendorColor(vendorId) {
                    const vendor = State.vendors.find(v => v.id === vendorId);
                    if (!vendor) return null;
                    
                    // If vendor already has a color, return it
                    if (vendor.color) return vendor.color;
                    
                    // Otherwise, generate and assign new color
                    vendor.color = this.generateVendorColor();
                    State.saveVendors();
                    return vendor.color;
                },
                
                // Get correct Polish plural form for "miejsce"
                getPolishPlural(count) {
                    // Get last digit
                    const lastDigit = count % 10;
                    // Get last two digits
                    const lastTwoDigits = count % 100;
                    
                    // Numbers ending with 1 (but not 11) use "miejsce"
                    if (lastDigit === 1 && lastTwoDigits !== 11) {
                        return 'miejsce';
                    }
                    
                    // Exception: numbers ending with 12, 13, 14 use "miejsc"
                    if (lastTwoDigits >= 12 && lastTwoDigits <= 14) {
                        return 'miejsc';
                    }
                    
                    // Numbers ending with 2, 3, 4 use "miejsca"
                    if (lastDigit >= 2 && lastDigit <= 4) {
                        return 'miejsca';
                    }
                    
                    // Everything else uses "miejsc" (0, 5-9, and teens)
                    return 'miejsc';
                },
                
                // Get correct Polish plural form for "dodany" (added)
                getPolishPluralAdded(count) {
                    const lastDigit = count % 10;
                    const lastTwoDigits = count % 100;
                    
                    if (lastDigit === 1 && lastTwoDigits !== 11) {
                        return 'dodane';
                    }
                    
                    if (lastTwoDigits >= 12 && lastTwoDigits <= 14) {
                        return 'dodanych';
                    }
                    
                    if (lastDigit >= 2 && lastDigit <= 4) {
                        return 'dodane';
                    }
                    
                    return 'dodanych';
                },
                
                // Get correct Polish plural form for "zmapowany" (mapped)
                getPolishPluralMapped(count) {
                    const lastDigit = count % 10;
                    const lastTwoDigits = count % 100;
                    
                    if (lastDigit === 1 && lastTwoDigits !== 11) {
                        return 'zmapowane';
                    }
                    
                    if (lastTwoDigits >= 12 && lastTwoDigits <= 14) {
                        return 'zmapowanych';
                    }
                    
                    if (lastDigit >= 2 && lastDigit <= 4) {
                        return 'zmapowane';
                    }
                    
                    return 'zmapowanych';
                }
            };

            // ============================================
            // DESIGNER MODULE
            // ============================================
            const Designer = {
                handlersSetup: false,

                init() {
                    this.setupEventListeners();
                },

                setupEventListeners() {
                    const mapWrapper = document.getElementById('mapWrapper');
                    const mapImage = document.getElementById('mapImage');

                    if (!mapWrapper || this.handlersSetup) return;

                    mapWrapper.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                    document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                    document.addEventListener('mouseup', (e) => this.handleMouseUp(e));

                    // Keyboard controls
                    document.addEventListener('keydown', (e) => this.handleKeyboard(e));

                    // Wait for image to load
                    if (mapImage.complete) {
                        this.handlersSetup = true;
                    } else {
                        mapImage.addEventListener('load', () => {
                            this.handlersSetup = true;
                        });
                    }
                },

                handleMouseDown(e) {
                    const mapImage = document.getElementById('mapImage');
                    const mapWrapper = document.getElementById('mapWrapper');
                    
                    if (e.target === mapImage || e.target === mapWrapper) {
                        this.startDrawing(e);
                    }
                },

                handleMouseMove(e) {
                    if (State.isDrawing) {
                        this.drawing(e);
                    } else if (State.isDragging) {
                        this.dragging(e);
                    }
                },

                handleMouseUp(e) {
                    if (State.isDrawing) {
                        this.endDrawing(e);
                    } else if (State.isDragging) {
                        this.endDragging();
                    }
                },

                handleKeyboard(e) {
                    if (!State.selectedSpot || !State.spots[State.selectedSpot] || !State.spots[State.selectedSpot].positioned) return;
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    if (!['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) return;
                    
                    const spot = State.spots[State.selectedSpot];
                    const mapImage = document.getElementById('mapImage');
                    const imageRect = mapImage.getBoundingClientRect();
                    
                    const actualWidth = mapImage.naturalWidth || imageRect.width;
                    const actualHeight = mapImage.naturalHeight || imageRect.height;
                    
                    const stepSize = e.shiftKey ? CONSTANTS.KEYBOARD_STEP_FAST : CONSTANTS.KEYBOARD_STEP_NORMAL;
                    const xStep = (stepSize / actualWidth) * 100;
                    const yStep = (stepSize / actualHeight) * 100;
                    
                    let moved = false;
                    switch(e.key) {
                        case 'ArrowLeft': spot.x = Math.max(0, spot.x - xStep); moved = true; break;
                        case 'ArrowRight': spot.x = Math.min(100, spot.x + xStep); moved = true; break;
                        case 'ArrowUp': spot.y = Math.max(0, spot.y - yStep); moved = true; break;
                        case 'ArrowDown': spot.y = Math.min(100, spot.y + yStep); moved = true; break;
                    }
                    
                    if (moved) {
                        e.preventDefault();
                        this.updateSpotsOverlay();
                    }
                },

                startDrawing(e) {
                    // Block if panning
                    if (State.isPanning || State.isControlPressed) return;
                    
                    if (!State.selectedSpot) return;
                    if (State.spots[State.selectedSpot].positioned) return;
                    
                    const mapImage = document.getElementById('mapImage');
                    const mapWrapper = document.getElementById('mapWrapper');
                    const imageRect = mapImage.getBoundingClientRect();
                    
                    // Account for zoom: divide by current zoom to get actual image coordinates
                    const adjustedX = e.clientX - imageRect.left;
                    const adjustedY = e.clientY - imageRect.top;
                    
                    // Get natural (unzoomed) dimensions for percentage calculation
                    const naturalWidth = mapImage.naturalWidth || imageRect.width / State.designerZoom;
                    const naturalHeight = mapImage.naturalHeight || imageRect.height / State.designerZoom;
                    
                    // Convert to percentage relative to natural image size
                    State.startX = (adjustedX / State.designerZoom / naturalWidth) * 100;
                    State.startY = (adjustedY / State.designerZoom / naturalHeight) * 100;
                    State.isDrawing = true;
                    
                    State.spots[State.selectedSpot].x = State.startX;
                    State.spots[State.selectedSpot].y = State.startY;
                    State.spots[State.selectedSpot].width = 1;
                    State.spots[State.selectedSpot].height = 1;
                    
                    e.preventDefault();
                },

                drawing(e) {
                    if (!State.isDrawing || !State.selectedSpot) return;
                    
                    const mapImage = document.getElementById('mapImage');
                    const imageRect = mapImage.getBoundingClientRect();
                    
                    // Account for zoom when calculating current position
                    const adjustedX = e.clientX - imageRect.left;
                    const adjustedY = e.clientY - imageRect.top;
                    
                    const naturalWidth = mapImage.naturalWidth || imageRect.width / State.designerZoom;
                    const naturalHeight = mapImage.naturalHeight || imageRect.height / State.designerZoom;
                    
                    const currentX = (adjustedX / State.designerZoom / naturalWidth) * 100;
                    const currentY = (adjustedY / State.designerZoom / naturalHeight) * 100;
                    
                    const widthPercent = Math.abs(currentX - State.startX);
                    const heightPercent = Math.abs(currentY - State.startY);
                    
                    // Calculate pixel dimensions based on natural size, not zoomed size
                    const widthPx = Math.round((widthPercent / 100) * naturalWidth);
                    const heightPx = Math.round((heightPercent / 100) * naturalHeight);
                    
                    State.spots[State.selectedSpot].width = Math.max(5, widthPx);
                    State.spots[State.selectedSpot].height = Math.max(5, heightPx);
                    State.spots[State.selectedSpot].x = Math.min(State.startX, currentX);
                    State.spots[State.selectedSpot].y = Math.min(State.startY, currentY);
                    
                    this.updateSpotsOverlay();
                },

                endDrawing(e) {
                    if (State.isDrawing && State.selectedSpot) {
                        const spot = State.spots[State.selectedSpot];
                        
                        if (spot.width < 10 || spot.height < 10) {
                            spot.width = CONSTANTS.DEFAULT_SPOT_WIDTH;
                            spot.height = CONSTANTS.DEFAULT_SPOT_HEIGHT;
                        }
                        
                        spot.positioned = true;
                        State.isDrawing = false;
                        
                        this.updateUI();
                    }
                },

                addSpot() {
                    const input = document.getElementById('newSpotNumber');
                    const spotNumber = input.value.trim();

                    if (!spotNumber) {
                        alert('Proszƒô wprowadziƒá numer miejsca');
                        return;
                    }

                    if (State.spots[spotNumber]) {
                        alert('Miejsce ju≈º istnieje!');
                        return;
                    }

                    State.setSpot(spotNumber, {
                        id: spotNumber,
                        x: null,
                        y: null,
                        width: CONSTANTS.DEFAULT_SPOT_WIDTH,
                        height: CONSTANTS.DEFAULT_SPOT_HEIGHT,
                        rotation: CONSTANTS.DEFAULT_ROTATION,
                        positioned: false
                    });

                    input.value = '';
                    this.updateUI();
                },

                selectSpot(spotId) {
                    State.selectedSpot = spotId;
                    const spot = State.spots[spotId];
                    const controlPanel = document.getElementById('controlPanel');
                    
                    if (spot.positioned) {
                        // Show control panel and update values
                        controlPanel.style.display = 'block';
                        document.getElementById('widthValue').value = spot.width;
                        document.getElementById('heightValue').value = spot.height;
                        document.getElementById('rotationValue').value = spot.rotation;
                        
                        const hint = document.getElementById('selectionHint');
                        hint.classList.remove('show');
                        
                        // Scroll to spot
                        const mapContainer = document.getElementById('mapContainer');
                        const overlay = document.getElementById('spotsOverlay');
                        const spotElement = overlay.querySelector(`[data-spot-id="${spotId}"]`);
                        
                        if (spotElement) {
                            const rect = spotElement.getBoundingClientRect();
                            const containerRect = mapContainer.getBoundingClientRect();
                            
                            mapContainer.scrollTo({
                                left: mapContainer.scrollLeft + (rect.left - containerRect.left) - containerRect.width / 2,
                                top: mapContainer.scrollTop + (rect.top - containerRect.top) - containerRect.height / 2,
                                behavior: 'smooth'
                            });
                        }
                    } else {
                        controlPanel.style.display = 'none';
                        const hint = document.getElementById('selectionHint');
                        hint.classList.add('show');
                        setTimeout(() => hint.classList.remove('show'), 5000);
                    }
                    
                    // Update UI to reflect selection
                    this.updateSpotsList();
                    this.updateSpotsOverlay();
                },

                deleteSpot(spotId) {
                    const spot = State.getSpot(spotId);
                    if (!spot) return;
                    
                    // Check if spot has assigned vendor
                    if (spot.vendorId) {
                        const vendor = State.vendors.find(v => v.id === spot.vendorId);
                        const vendorName = vendor ? vendor.name : 'Nieznany';
                        
                        const message = `‚ö†Ô∏è UWAGA: Do miejsca ${spotId} przypisany jest vendor "${vendorName}".\n\nCzy na pewno chcesz je usunƒÖƒá?\n\nPotwierdzenie usunie miejsce oraz odepnie je od vendora.`;
                        
                        if (!confirm(message)) {
                            return;
                        }
                    } else {
                        // No vendor assigned, simple confirmation
                        if (!confirm(`Czy na pewno chcesz usunƒÖƒá miejsce ${spotId}?`)) {
                            return;
                        }
                    }
                    
                    State.deleteSpot(spotId);
                    document.getElementById('controlPanel').style.display = 'none';
                    this.updateUI();
                },

                adjustWidth(delta) {
                    if (!State.selectedSpot) return;
                    const spot = State.spots[State.selectedSpot];
                    spot.width = Math.max(CONSTANTS.MIN_DIMENSION, Math.min(CONSTANTS.MAX_DIMENSION, spot.width + delta));
                    document.getElementById('widthValue').value = spot.width;
                    this.updateSpotsOverlay();
                },

                adjustHeight(delta) {
                    if (!State.selectedSpot) return;
                    const spot = State.spots[State.selectedSpot];
                    spot.height = Math.max(CONSTANTS.MIN_DIMENSION, Math.min(CONSTANTS.MAX_DIMENSION, spot.height + delta));
                    document.getElementById('heightValue').value = spot.height;
                    this.updateSpotsOverlay();
                },

                adjustRotation(delta) {
                    if (!State.selectedSpot) return;
                    const spot = State.spots[State.selectedSpot];
                    spot.rotation = (spot.rotation + delta + 360) % 360;
                    document.getElementById('rotationValue').value = spot.rotation;
                    this.updateSpotsOverlay();
                },

                updateDimensions() {
                    if (!State.selectedSpot) return;
                    const spot = State.spots[State.selectedSpot];
                    spot.width = parseInt(document.getElementById('widthValue').value) || CONSTANTS.DEFAULT_SPOT_WIDTH;
                    spot.height = parseInt(document.getElementById('heightValue').value) || CONSTANTS.DEFAULT_SPOT_HEIGHT;
                    spot.rotation = parseInt(document.getElementById('rotationValue').value) || CONSTANTS.DEFAULT_ROTATION;
                    this.updateSpotsOverlay();
                    this.updateSpotsList();
                },

                updateSpotsList() {
                    const container = document.getElementById('spotsList');
                    container.innerHTML = '';

                    const sortedSpots = State.getSortedSpots();

                    sortedSpots.forEach(spot => {
                        const item = document.createElement('div');
                        item.className = 'spot-item' + 
                                        (spot.positioned ? ' positioned' : '') +
                                        (State.selectedSpot === spot.id ? ' active' : '');
                        
                        item.innerHTML = `
                            <div class="spot-info">
                                <div class="spot-number">${spot.id}</div>
                                ${!spot.positioned ? 
                                    '<div class="spot-coords spot-unmapped">Miejsce niezmapowane</div>' :
                                    spot.vendorId ? 
                                        '<div class="spot-coords spot-assigned">Miejsce przypisane</div>' :
                                        '<div class="spot-coords spot-mapped">Miejsce zmapowane</div>'
                                }
                            </div>
                            <div class="spot-actions">
                                <button class="icon-btn" onclick="app.designer.deleteSpot('${spot.id}')" title="Usu≈Ñ">üóëÔ∏è</button>
                            </div>
                        `;

                        item.addEventListener('click', (e) => {
                            if (!e.target.closest('.spot-actions')) {
                                this.selectSpot(spot.id);
                            }
                        });

                        container.appendChild(item);
                    });
                },

                updateSpotsOverlay() {
                    const overlay = document.getElementById('spotsOverlay');
                    const mapImage = document.getElementById('mapImage');
                    
                    if (!overlay || !mapImage) return;
                    
                    overlay.innerHTML = '';
                    
                    // Use natural dimensions for correct positioning regardless of zoom
                    const naturalWidth = mapImage.naturalWidth || mapImage.width;
                    const naturalHeight = mapImage.naturalHeight || mapImage.height;
                    
                    State.getPositionedSpots().forEach(spot => {
                        const rect = document.createElement('div');
                        rect.className = 'parking-rect' + (State.selectedSpot === spot.id ? ' selected' : '');
                        rect.dataset.spotId = spot.id;
                        
                        // Calculate position based on natural dimensions
                        const leftPx = Utils.percentToPx(spot.x, naturalWidth);
                        const topPx = Utils.percentToPx(spot.y, naturalHeight);
                        
                        rect.style.left = leftPx + 'px';
                        rect.style.top = topPx + 'px';
                        rect.style.width = spot.width + 'px';
                        rect.style.height = spot.height + 'px';
                        rect.style.transform = `rotate(${spot.rotation}deg)`;
                        rect.style.transformOrigin = 'center center';
                        
                        const label = document.createElement('div');
                        label.className = 'spot-label';
                        label.textContent = spot.id;
                        label.style.transform = spot.height > spot.width ? 
                            'translate(-50%, -50%) rotate(90deg)' : 
                            'translate(-50%, -50%)';
                        
                        rect.appendChild(label);
                        
                        // Drag to move (also selects the spot)
                        rect.addEventListener('mousedown', (e) => {
                            e.stopPropagation();
                            this.startDragging(e, spot.id);
                        });
                        
                        overlay.appendChild(rect);
                    });
                },

                startDragging(e, spotId) {
                    // Block if panning
                    if (State.isPanning || State.isControlPressed) return;
                    
                    if (e.button !== 0) return; // Only left mouse button
                    
                    State.isDragging = true;
                    
                    // Select the spot and show controls
                    this.selectSpot(spotId);
                    
                    const mapImage = document.getElementById('mapImage');
                    const naturalWidth = mapImage.naturalWidth || mapImage.width;
                    const naturalHeight = mapImage.naturalHeight || mapImage.height;
                    const imageRect = mapImage.getBoundingClientRect();
                    
                    const spot = State.spots[spotId];
                    
                    // Calculate offset from mouse to spot's top-left corner
                    const adjustedX = e.clientX - imageRect.left;
                    const adjustedY = e.clientY - imageRect.top;
                    
                    const mouseXPercent = (adjustedX / State.designerZoom / naturalWidth) * 100;
                    const mouseYPercent = (adjustedY / State.designerZoom / naturalHeight) * 100;
                    
                    State.dragStartX = mouseXPercent - spot.x;
                    State.dragStartY = mouseYPercent - spot.y;
                    
                    // Add dragging class
                    const rectElement = document.querySelector(`[data-spot-id="${spotId}"]`);
                    if (rectElement) {
                        rectElement.classList.add('dragging');
                    }
                    
                    // Prevent text selection
                    e.preventDefault();
                },

                dragging(e) {
                    if (!State.isDragging || !State.selectedSpot) return;
                    
                    const spot = State.spots[State.selectedSpot];
                    const mapImage = document.getElementById('mapImage');
                    const naturalWidth = mapImage.naturalWidth || mapImage.width;
                    const naturalHeight = mapImage.naturalHeight || mapImage.height;
                    const imageRect = mapImage.getBoundingClientRect();
                    
                    const adjustedX = e.clientX - imageRect.left;
                    const adjustedY = e.clientY - imageRect.top;
                    
                    const mouseXPercent = (adjustedX / State.designerZoom / naturalWidth) * 100;
                    const mouseYPercent = (adjustedY / State.designerZoom / naturalHeight) * 100;
                    
                    // Update spot position accounting for drag offset
                    spot.x = Math.max(0, Math.min(100, mouseXPercent - State.dragStartX));
                    spot.y = Math.max(0, Math.min(100, mouseYPercent - State.dragStartY));
                    
                    this.updateSpotsOverlay();
                    this.updateSpotsList();
                },

                endDragging() {
                    if (State.isDragging) {
                        State.isDragging = false;
                        
                        // Remove dragging class
                        const rectElement = document.querySelector('.dragging');
                        if (rectElement) {
                            rectElement.classList.remove('dragging');
                        }
                        
                        this.updateSpotsOverlay();
                    }
                },

                updateStats() {
                    const total = Object.keys(State.spots).length;
                    const positioned = State.getPositionedSpots().length;
                    document.getElementById('statsText').textContent = 
                        `${total} ${Utils.getPolishPlural(total)} ${Utils.getPolishPluralAdded(total)}, ${positioned} ${Utils.getPolishPluralMapped(positioned)}`;
                },

                updateUI() {
                    this.updateSpotsList();
                    this.updateSpotsOverlay();
                    this.updateStats();
                },

                loadSampleData() {
                    if (Object.keys(State.spots).length > 0) {
                        if (!confirm('To zastƒÖpi istniejƒÖce miejsca. Kontynuowaƒá?')) {
                            return;
                        }
                    }

                    State.spots = {};
                    
                    // Load sample spots (001-760 + special)
                    for (let i = 1; i <= 177; i++) {
                        const id = String(i).padStart(3, '0');
                        State.setSpot(id, { 
                            id, x: null, y: null, 
                            width: CONSTANTS.DEFAULT_SPOT_WIDTH, 
                            height: CONSTANTS.DEFAULT_SPOT_HEIGHT, 
                            rotation: CONSTANTS.DEFAULT_ROTATION, 
                            positioned: false 
                        });
                    }
                    
                    for (let i = 178; i <= 310; i++) {
                        State.setSpot(String(i), { 
                            id: String(i), x: null, y: null, 
                            width: CONSTANTS.DEFAULT_SPOT_WIDTH, 
                            height: CONSTANTS.DEFAULT_SPOT_HEIGHT, 
                            rotation: CONSTANTS.DEFAULT_ROTATION, 
                            positioned: false 
                        });
                    }
                    
                    for (let i = 313; i <= 425; i++) {
                        State.setSpot(String(i), { 
                            id: String(i), x: null, y: null, 
                            width: CONSTANTS.DEFAULT_SPOT_WIDTH, 
                            height: CONSTANTS.DEFAULT_SPOT_HEIGHT, 
                            rotation: CONSTANTS.DEFAULT_ROTATION, 
                            positioned: false 
                        });
                    }
                    
                    for (let i = 428; i <= 760; i++) {
                        State.setSpot(String(i), { 
                            id: String(i), x: null, y: null, 
                            width: CONSTANTS.DEFAULT_SPOT_WIDTH, 
                            height: CONSTANTS.DEFAULT_SPOT_HEIGHT, 
                            rotation: CONSTANTS.DEFAULT_ROTATION, 
                            positioned: false 
                        });
                    }

                    const specialSpots = ['121A', '178a', '265A', '291A', '378A', '378B', '760A', '760B'];
                    specialSpots.forEach(id => {
                        State.setSpot(id, { 
                            id, x: null, y: null, 
                            width: CONSTANTS.DEFAULT_SPOT_WIDTH, 
                            height: CONSTANTS.DEFAULT_SPOT_HEIGHT, 
                            rotation: CONSTANTS.DEFAULT_ROTATION, 
                            positioned: false 
                        });
                    });

                    this.updateUI();
                    alert('Przyk≈Çadowe miejsca wczytane! Wybierz miejsce i narysuj prostokƒÖt na mapie.');
                }
            };

            // ============================================
            // MANAGER MODULE
            // ============================================
            const Manager = {
                init() {
                    // Manager initialization
                },

                getSpotStatus(spotId) {
                    const spot = State.getSpot(spotId);
                    if (!spot) return 'available';
                    
                    // Spot is occupied if it has a vendor assigned
                    return spot.vendorId ? 'occupied' : 'available';
                },

                refreshView() {
                    this.updateStatistics();
                    this.renderManagerOverlay();
                    this.renderVendorsList();
                },
                
                renderVendorsList() {
                    const vendorsList = document.getElementById('vendorsList');
                    if (!vendorsList) return;
                    
                    // Sort vendors alphabetically by name
                    const sortedVendors = [...State.vendors].sort((a, b) => 
                        a.name.localeCompare(b.name, 'pl')
                    );
                    
                    if (sortedVendors.length === 0) {
                        vendorsList.innerHTML = '<div style="color: #999; font-size: 0.85rem; padding: 1rem; text-align: center;">Brak vendor√≥w</div>';
                        return;
                    }
                    
                    vendorsList.innerHTML = sortedVendors.map(vendor => {
                        // Get spots assigned to this vendor
                        const vendorSpots = Object.values(State.spots).filter(spot => 
                            spot.vendorId === vendor.id && spot.positioned
                        );
                        
                        // Sort spot IDs alphabetically
                        const spotIds = vendorSpots.map(s => s.id).sort((a, b) => 
                            a.localeCompare(b, 'pl', { numeric: true })
                        );
                        
                        const spotsCount = vendorSpots.length;
                        const vendorColor = Utils.getVendorColor(vendor.id) || '#999';
                        
                        return `
                            <div class="vendor-item" data-vendor-id="${vendor.id}" onclick="app.manager.toggleVendorDetails(${vendor.id})" style="border-left-color: ${vendorColor}; border-right-color: ${vendorColor};">
                                <div class="vendor-item-header">
                                    <div class="vendor-item-name">${vendor.name}</div>
                                </div>
                                <div class="vendor-item-count">${spotsCount} ${Utils.getPolishPlural(spotsCount)}</div>
                                
                                <div class="vendor-item-details">
                                    <div class="vendor-detail-row">
                                        <span class="vendor-detail-label">Osoba kontaktowa:</span>
                                        ${vendor.contact || '<em style="color: #999;">brak</em>'}
                                    </div>
                                    <div class="vendor-detail-row">
                                        <span class="vendor-detail-label">Telefon:</span>
                                        ${vendor.phone || '<em style="color: #999;">brak</em>'}
                                    </div>
                                    <div class="vendor-detail-row">
                                        <span class="vendor-detail-label">Email:</span>
                                        ${vendor.email || '<em style="color: #999;">brak</em>'}
                                    </div>
                                    ${spotsCount > 0 ? `
                                        <div class="vendor-detail-row" style="margin-top: 0.8rem;">
                                            <span class="vendor-detail-label">Przypisane miejsca (${spotsCount}):</span>
                                            <div class="vendor-spots-list">${spotIds.join(', ')}</div>
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        `;
                    }).join('');
                },
                
                toggleVendorDetails(vendorId) {
                    const vendorItem = document.querySelector(`.vendor-item[data-vendor-id="${vendorId}"]`);
                    if (!vendorItem) return;
                    
                    const wasExpanded = vendorItem.classList.contains('expanded');
                    
                    // Close all other vendor items
                    document.querySelectorAll('.vendor-item').forEach(item => {
                        item.classList.remove('expanded');
                    });
                    
                    if (!wasExpanded) {
                        // Expand this item
                        vendorItem.classList.add('expanded');
                        
                        // Highlight vendor spots on map
                        this.highlightVendorSpots(vendorId);
                    } else {
                        // If was expanded and clicked again, close and remove highlights
                        this.clearVendorHighlights();
                    }
                },
                
                highlightVendorSpots(vendorId) {
                    // Remove all existing highlights
                    this.clearVendorHighlights();
                    
                    // Add highlight class to vendor's spots
                    Object.values(State.spots).forEach(spot => {
                        if (spot.vendorId === vendorId && spot.positioned) {
                            const spotElement = document.querySelector(`.manager-parking-spot[data-spot-id="${spot.id}"]`);
                            if (spotElement) {
                                spotElement.classList.add('vendor-highlighted');
                            }
                        }
                    });
                },
                
                clearVendorHighlights() {
                    document.querySelectorAll('.manager-parking-spot').forEach(el => {
                        el.classList.remove('vendor-highlighted');
                    });
                },

                updateStatistics() {
                    const positionedSpots = State.getPositionedSpots();
                    const total = positionedSpots.length;
                    
                    let available = 0, occupied = 0;
                    let totalValue = 0, availableValue = 0, occupiedValue = 0;
                    
                    positionedSpots.forEach(spot => {
                        const status = this.getSpotStatus(spot.id);
                        const price = spot.priceId ? State.prices.find(p => p.id === spot.priceId) : null;
                        const priceValue = price ? price.price : 0;
                        
                        // Count spots
                        if (status === 'available') {
                            available++;
                            // Available: has price but no vendor
                            if (price) {
                                availableValue += priceValue;
                            }
                        } else if (status === 'occupied') {
                            occupied++;
                            // Occupied: has vendor (and optionally price)
                            if (price) {
                                occupiedValue += priceValue;
                            }
                        }
                        
                        // Total value: all spots with prices (regardless of vendor)
                        if (price) {
                            totalValue += priceValue;
                        }
                    });

                    // Update counts
                    document.getElementById('totalSpots').textContent = total;
                    document.getElementById('availableSpots').textContent = available;
                    document.getElementById('occupiedSpots').textContent = occupied;
                    
                    // Update values
                    document.getElementById('totalValue').textContent = this.formatCurrency(totalValue);
                    document.getElementById('availableValue').textContent = this.formatCurrency(availableValue);
                    document.getElementById('occupiedValue').textContent = this.formatCurrency(occupiedValue);
                },
                
                formatCurrency(value) {
                    return value.toFixed(2).replace('.', ',') + ' PLN';
                },

                renderManagerOverlay() {
                    const overlay = document.getElementById('spotsOverlayManager');
                    const mapImage = document.getElementById('mapImageManager');
                    
                    if (!overlay || !mapImage) return;
                    
                    overlay.innerHTML = '';
                    
                    // Use natural dimensions for correct positioning regardless of zoom
                    const naturalWidth = mapImage.naturalWidth || mapImage.width;
                    const naturalHeight = mapImage.naturalHeight || mapImage.height;
                    
                    State.getPositionedSpots().forEach(spot => {
                        const status = this.getSpotStatus(spot.id);
                        
                        const rect = document.createElement('div');
                        rect.className = `manager-parking-spot ${status}`;
                        rect.dataset.spotId = spot.id;
                        
                        // Calculate position based on natural dimensions
                        const leftPx = Utils.percentToPx(spot.x, naturalWidth);
                        const topPx = Utils.percentToPx(spot.y, naturalHeight);
                        
                        rect.style.left = leftPx + 'px';
                        rect.style.top = topPx + 'px';
                        rect.style.width = spot.width + 'px';
                        rect.style.height = spot.height + 'px';
                        rect.style.transform = `rotate(${spot.rotation}deg)`;
                        rect.style.transformOrigin = 'center center';
                        
                        // Apply vendor color if assigned
                        if (spot.vendorId) {
                            const vendorColor = Utils.getVendorColor(spot.vendorId);
                            if (vendorColor) {
                                rect.style.backgroundColor = vendorColor;
                                rect.dataset.vendorColor = vendorColor;
                            }
                        }
                        
                        const label = document.createElement('div');
                        label.className = 'spot-label';
                        label.textContent = spot.id;
                        label.style.transform = spot.height > spot.width ? 
                            'translate(-50%, -50%) rotate(90deg)' : 
                            'translate(-50%, -50%)';
                        
                        rect.appendChild(label);
                        
                        rect.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.showSpotDetails(spot.id);
                        });
                        
                        overlay.appendChild(rect);
                    });
                },

                showSpotDetails(spotId) {
                    const spot = State.getSpot(spotId);
                    
                    // Close all expanded vendor items
                    document.querySelectorAll('.vendor-item').forEach(item => {
                        item.classList.remove('expanded');
                    });
                    
                    // Clear vendor highlights
                    this.clearVendorHighlights();
                    
                    // Remove selected class from all spots
                    document.querySelectorAll('.manager-parking-spot').forEach(el => {
                        el.classList.remove('selected');
                    });
                    
                    // Add selected class to clicked spot
                    const selectedSpot = document.querySelector(`[data-spot-id="${spotId}"]`);
                    if (selectedSpot) {
                        selectedSpot.classList.add('selected');
                    }
                    
                    const detailsSection = document.getElementById('spotDetailsSection');
                    const detailsContent = document.getElementById('spotDetails');
                    
                    detailsSection.style.display = 'block';
                    
                    // Get current assignments
                    const currentVendorId = spot.vendorId || null;
                    const currentPriceId = spot.priceId || null;
                    const currentPrice = currentPriceId ? State.prices.find(p => p.id === currentPriceId) : null;
                    
                    // Build vendor options
                    const vendorOptions = State.vendors.map(v => 
                        `<option value="${v.id}" ${v.id === currentVendorId ? 'selected' : ''}>${v.name}</option>`
                    ).join('');
                    
                    // Build price options with price values
                    const priceOptions = State.prices.map(p => 
                        `<option value="${p.id}" ${p.id === currentPriceId ? 'selected' : ''}>${p.name} (${p.price.toFixed(2).replace('.', ',')} PLN)</option>`
                    ).join('');
                    
                    detailsContent.innerHTML = `
                        <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px;">
                            <h4 style="margin-bottom: 1rem; color: #303030;">Miejsce: ${spot.id}</h4>
                            
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; font-weight: 600; margin-bottom: 0.5rem; font-size: 0.9rem;">Nazwa vendora:</label>
                                <select id="vendorSelect" style="width: 100%; padding: 0.5rem; border: 2px solid #e0e0e0; border-radius: 4px; font-size: 0.9rem;">
                                    <option value="">-- Wybierz vendora --</option>
                                    ${vendorOptions}
                                </select>
                            </div>
                            
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; font-weight: 600; margin-bottom: 0.5rem; font-size: 0.9rem;">Cena za miejsce:</label>
                                <select id="priceSelect" style="width: 100%; padding: 0.5rem; border: 2px solid #e0e0e0; border-radius: 4px; font-size: 0.9rem;">
                                    <option value="">-- Wybierz cenƒô --</option>
                                    ${priceOptions}
                                </select>
                            </div>
                            
                            <div style="display: flex; gap: 0.5rem; margin-top: 1rem;">
                                <button onclick="app.manager.saveSpotAssignment('${spotId}')" 
                                        style="flex: 1; padding: 0.6rem; background: #10b981; color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">
                                    Zapisz
                                </button>
                                <button onclick="app.manager.releaseSpot('${spotId}')" 
                                        style="flex: 1; padding: 0.6rem; background: #ef4444; color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">
                                    Zwolnij
                                </button>
                                <button onclick="app.manager.cancelEdit()" 
                                        style="padding: 0.6rem 1rem; background: #6b7280; color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">
                                    Anuluj
                                </button>
                            </div>
                        </div>
                    `;
                },
                
                saveSpotAssignment(spotId) {
                    const vendorId = document.getElementById('vendorSelect').value;
                    const priceId = document.getElementById('priceSelect').value;
                    const spot = State.getSpot(spotId);
                    
                    if (!spot) return;
                    
                    // Assign vendor and price
                    spot.vendorId = vendorId ? parseInt(vendorId) : null;
                    spot.priceId = priceId ? parseInt(priceId) : null;
                    
                    // If vendor is assigned, ensure it has a color
                    if (spot.vendorId) {
                        Utils.getVendorColor(spot.vendorId);
                    }
                    
                    // Save to localStorage
                    State.saveSpots();
                    
                    // Refresh view
                    this.renderManagerOverlay();
                    this.updateStatistics();
                    this.renderVendorsList();
                    
                    // Close panel
                    document.getElementById('spotDetailsSection').style.display = 'none';
                    
                    // Remove selected class
                    document.querySelectorAll('.manager-parking-spot').forEach(el => {
                        el.classList.remove('selected');
                    });
                },
                
                releaseSpot(spotId) {
                    const spot = State.getSpot(spotId);
                    if (!spot) return;
                    
                    if (confirm(`Czy na pewno chcesz zwolniƒá miejsce ${spotId}?`)) {
                        // Remove assignments
                        spot.vendorId = null;
                        spot.priceId = null;
                        
                        // Save to localStorage
                        State.saveSpots();
                        
                        // Refresh view
                        this.renderManagerOverlay();
                        this.updateStatistics();
                        this.renderVendorsList();
                        
                        // Close panel
                        document.getElementById('spotDetailsSection').style.display = 'none';
                        
                        // Remove selected class
                        document.querySelectorAll('.manager-parking-spot').forEach(el => {
                            el.classList.remove('selected');
                        });
                    }
                },
                
                cancelEdit() {
                    // Close panel
                    document.getElementById('spotDetailsSection').style.display = 'none';
                    
                    // Remove selected class
                    document.querySelectorAll('.manager-parking-spot').forEach(el => {
                        el.classList.remove('selected');
                    });
                }
            };

            // ============================================
            // VENDORS MODULE
            // ============================================
            const Vendors = {
                init() {
                    this.renderTable();
                    // Attach form submit event listener with proper context
                    const vendorForm = document.getElementById('vendorForm');
                    const self = this;
                    if (vendorForm) {
                        vendorForm.addEventListener('submit', function(e) {
                            self.handleSubmit(e);
                        });
                    }
                },

                renderTable() {
                    const tbody = document.getElementById('vendorsTableBody');
                    const emptyState = document.getElementById('vendorsEmptyState');
                    
                    if (State.vendors.length === 0) {
                        tbody.innerHTML = '';
                        emptyState.style.display = 'block';
                        this.updateSortHeaders();
                        return;
                    }

                    emptyState.style.display = 'none';
                    
                    // Get sorted vendors
                    let sortedVendors = [...State.vendors];
                    
                    if (State.vendorSortColumn) {
                        sortedVendors.sort((a, b) => {
                            let aVal, bVal;
                            
                            if (State.vendorSortColumn === 'id') {
                                aVal = a.id;
                                bVal = b.id;
                            } else if (State.vendorSortColumn === 'name') {
                                aVal = a.name.toLowerCase();
                                bVal = b.name.toLowerCase();
                            }
                            
                            if (State.vendorSortDirection === 'asc') {
                                return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
                            } else {
                                return aVal < bVal ? 1 : aVal > bVal ? -1 : 0;
                            }
                        });
                    }
                    
                    tbody.innerHTML = sortedVendors.map(vendor => {
                        // Count spots assigned to this vendor
                        const spotsCount = Object.values(State.spots).filter(spot => 
                            spot.positioned && spot.vendorId === vendor.id
                        ).length;
                        
                        return `
                            <tr>
                                <td>${vendor.id}</td>
                                <td><strong>${vendor.name}</strong></td>
                                <td>${vendor.contact || '-'}</td>
                                <td>${vendor.email || '-'}</td>
                                <td class="nowrap">${vendor.phone || '-'}</td>
                                <td><strong>${spotsCount}</strong></td>
                                <td>
                                    <div class="vendor-actions">
                                        <button class="btn-icon btn-edit" onclick="app.vendors.openEditModal(${vendor.id})" title="Edytuj">
                                            ‚úèÔ∏è
                                        </button>
                                        <button class="btn-icon btn-delete" onclick="app.vendors.deleteVendor(${vendor.id})" title="Usu≈Ñ">
                                            üóëÔ∏è
                                        </button>
                                    </div>
                                </td>
                            </tr>
                        `;
                    }).join('');
                    
                    this.updateSortHeaders();
                },

                sortBy(column) {
                    // Toggle direction if same column, otherwise reset to asc
                    if (State.vendorSortColumn === column) {
                        State.vendorSortDirection = State.vendorSortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        State.vendorSortColumn = column;
                        State.vendorSortDirection = 'asc';
                    }
                    
                    this.renderTable();
                },

                updateSortHeaders() {
                    // Remove all sort classes
                    document.querySelectorAll('.vendors-table th.sortable').forEach(th => {
                        th.classList.remove('sort-asc', 'sort-desc');
                    });
                    
                    // Add class to active sorted column
                    if (State.vendorSortColumn) {
                        const columnIndex = State.vendorSortColumn === 'id' ? 0 : 1;
                        const th = document.querySelectorAll('.vendors-table th.sortable')[columnIndex];
                        if (th) {
                            th.classList.add(`sort-${State.vendorSortDirection}`);
                        }
                    }
                },

                openAddModal() {
                    State.editingVendorId = null;
                    document.getElementById('vendorModalTitle').textContent = 'Dodaj Vendora';
                    document.getElementById('vendorForm').reset();
                    this.clearErrors();
                    
                    // Show "Save and Add Another" button in add mode
                    const saveAndAddBtn = document.getElementById('saveAndAddAnotherBtn');
                    if (saveAndAddBtn) saveAndAddBtn.style.display = 'inline-block';
                    
                    document.getElementById('vendorModal').classList.add('show');
                },

                openEditModal(vendorId) {
                    const vendor = State.vendors.find(v => v.id === vendorId);
                    if (!vendor) return;

                    State.editingVendorId = vendorId;
                    document.getElementById('vendorModalTitle').textContent = 'Edytuj Vendora';
                    document.getElementById('vendorName').value = vendor.name;
                    document.getElementById('vendorContact').value = vendor.contact || '';
                    document.getElementById('vendorEmail').value = vendor.email || '';
                    document.getElementById('vendorPhone').value = vendor.phone || '';
                    this.clearErrors();
                    
                    // Hide "Save and Add Another" button in edit mode
                    const saveAndAddBtn = document.getElementById('saveAndAddAnotherBtn');
                    if (saveAndAddBtn) saveAndAddBtn.style.display = 'none';
                    
                    document.getElementById('vendorModal').classList.add('show');
                },

                closeModal() {
                    document.getElementById('vendorModal').classList.remove('show');
                    document.getElementById('vendorForm').reset();
                    this.clearErrors();
                    State.editingVendorId = null;
                },

                clearErrors() {
                    document.getElementById('vendorNameError').classList.remove('show');
                    document.getElementById('vendorName').classList.remove('error');
                },

                handleSubmit(event) {
                    event.preventDefault();
                    
                    const name = document.getElementById('vendorName').value.trim();
                    const contact = document.getElementById('vendorContact').value.trim();
                    const email = document.getElementById('vendorEmail').value.trim();
                    const phone = document.getElementById('vendorPhone').value.trim();

                    // Validate unique name
                    const existingVendor = State.vendors.find(v => 
                        v.name.toLowerCase() === name.toLowerCase() && 
                        v.id !== State.editingVendorId
                    );

                    if (existingVendor) {
                        document.getElementById('vendorNameError').classList.add('show');
                        document.getElementById('vendorName').classList.add('error');
                        return;
                    }

                    if (State.editingVendorId) {
                        // Edit existing vendor
                        const vendor = State.vendors.find(v => v.id === State.editingVendorId);
                        if (vendor) {
                            vendor.name = name;
                            vendor.contact = contact;
                            vendor.email = email;
                            vendor.phone = phone;
                        }
                    } else {
                        // Add new vendor
                        State.vendors.push({
                            id: State.nextVendorId++,
                            name: name,
                            contact: contact,
                            email: email,
                            phone: phone
                        });
                    }

                    State.saveVendors();
                    this.renderTable();
                    this.closeModal();
                },

                saveAndAddAnother() {
                    // Validate and save vendor
                    const name = document.getElementById('vendorName').value.trim();
                    const contact = document.getElementById('vendorContact').value.trim();
                    const email = document.getElementById('vendorEmail').value.trim();
                    const phone = document.getElementById('vendorPhone').value.trim();

                    // Check if name is provided
                    if (!name) {
                        alert('Nazwa vendora jest wymagana');
                        return;
                    }

                    // Validate unique name
                    const existingVendor = State.vendors.find(v => 
                        v.name.toLowerCase() === name.toLowerCase() && 
                        v.id !== State.editingVendorId
                    );

                    if (existingVendor) {
                        document.getElementById('vendorNameError').classList.add('show');
                        document.getElementById('vendorName').classList.add('error');
                        return;
                    }

                    // Add new vendor (only works in add mode, not edit)
                    if (!State.editingVendorId) {
                        State.vendors.push({
                            id: State.nextVendorId++,
                            name: name,
                            contact: contact,
                            email: email,
                            phone: phone
                        });

                        State.saveVendors();
                        this.renderTable();
                        
                        // Clear form but keep modal open
                        document.getElementById('vendorForm').reset();
                        this.clearErrors();
                        
                        // Focus on name field for next entry
                        document.getElementById('vendorName').focus();
                    }
                },

                deleteVendor(vendorId) {
                    const vendor = State.vendors.find(v => v.id === vendorId);
                    if (!vendor) return;

                    // Count spots assigned to this vendor
                    const assignedSpots = Object.values(State.spots).filter(spot => 
                        spot.positioned && spot.vendorId === vendorId
                    );
                    const spotsCount = assignedSpots.length;
                    
                    // Build confirmation message
                    let message = `Czy na pewno chcesz usunƒÖƒá vendora "${vendor.name}"?`;
                    if (spotsCount > 0) {
                        message += `\n\n‚ö†Ô∏è UWAGA: Vendor ma przypisane ${spotsCount} ${Utils.getPolishPlural(spotsCount)}.\nMiejsca zostanƒÖ zwolnione.`;
                    }

                    if (confirm(message)) {
                        // Release all spots assigned to this vendor
                        Object.values(State.spots).forEach(spot => {
                            if (spot.vendorId === vendorId) {
                                spot.vendorId = null;
                                spot.priceId = null;
                            }
                        });
                        
                        // Save spots after releasing
                        State.saveSpots();
                        
                        // Remove vendor
                        State.vendors = State.vendors.filter(v => v.id !== vendorId);
                        State.saveVendors();
                        
                        // Refresh all views
                        this.renderTable();
                        
                        // Refresh Manager if it exists
                        if (app.manager) {
                            app.manager.refreshView();
                        }
                        
                        // Refresh Seller if on that tab
                        if (State.currentTab === 'seller' && app.seller) {
                            app.seller.init();
                        }
                    }
                }
            };

            // ============================================
            // PRICES MODULE
            // ============================================
            const Prices = {
                init() {
                    this.renderTable();
                    // Attach form submit event listener with proper context
                    const priceForm = document.getElementById('priceForm');
                    const self = this;
                    if (priceForm) {
                        priceForm.addEventListener('submit', function(e) {
                            self.handleSubmit(e);
                        });
                    }
                },

                renderTable() {
                    const tbody = document.getElementById('pricesTableBody');
                    const emptyState = document.getElementById('pricesEmptyState');
                    
                    if (State.prices.length === 0) {
                        tbody.innerHTML = '';
                        emptyState.style.display = 'block';
                        return;
                    }

                    emptyState.style.display = 'none';
                    
                    tbody.innerHTML = State.prices.map(price => {
                        // Count spots using this price
                        const spotsCount = Object.values(State.spots).filter(spot => 
                            spot.positioned && spot.priceId === price.id
                        ).length;
                        
                        return `
                            <tr>
                                <td>${price.id}</td>
                                <td><strong>${price.name}</strong></td>
                                <td><span class="price-value">${this.formatPrice(price.price)}</span></td>
                                <td><strong>${spotsCount}</strong></td>
                                <td>
                                    <div class="vendor-actions">
                                        <button class="btn-icon btn-edit" onclick="app.prices.openEditModal(${price.id})" title="Edytuj">
                                            ‚úèÔ∏è
                                        </button>
                                        <button class="btn-icon btn-delete" onclick="app.prices.deletePrice(${price.id})" title="Usu≈Ñ">
                                            üóëÔ∏è
                                        </button>
                                    </div>
                                </td>
                            </tr>
                        `;
                    }).join('');
                },

                formatPrice(price) {
                    return parseFloat(price).toFixed(2).replace('.', ',');
                },

                openAddModal() {
                    State.editingPriceId = null;
                    document.getElementById('priceModalTitle').textContent = 'Dodaj Cenƒô';
                    document.getElementById('priceForm').reset();
                    this.clearErrors();
                    document.getElementById('priceModal').classList.add('show');
                },

                openEditModal(priceId) {
                    const price = State.prices.find(p => p.id === priceId);
                    if (!price) return;

                    State.editingPriceId = priceId;
                    document.getElementById('priceModalTitle').textContent = 'Edytuj Cenƒô';
                    document.getElementById('priceName').value = price.name;
                    document.getElementById('priceValue').value = price.price;
                    this.clearErrors();
                    document.getElementById('priceModal').classList.add('show');
                },

                closeModal() {
                    document.getElementById('priceModal').classList.remove('show');
                    document.getElementById('priceForm').reset();
                    this.clearErrors();
                    State.editingPriceId = null;
                },

                clearErrors() {
                    document.getElementById('priceNameError').classList.remove('show');
                    document.getElementById('priceName').classList.remove('error');
                    document.getElementById('priceValueError').classList.remove('show');
                    document.getElementById('priceValue').classList.remove('error');
                },

                handleSubmit(event) {
                    event.preventDefault();
                    
                    const name = document.getElementById('priceName').value.trim();
                    const priceValue = parseFloat(document.getElementById('priceValue').value);

                    // Validate positive price
                    if (priceValue <= 0) {
                        document.getElementById('priceValueError').classList.add('show');
                        document.getElementById('priceValue').classList.add('error');
                        return;
                    }

                    // Validate unique name
                    const existingPrice = State.prices.find(p => 
                        p.name.toLowerCase() === name.toLowerCase() && 
                        p.id !== State.editingPriceId
                    );

                    if (existingPrice) {
                        document.getElementById('priceNameError').classList.add('show');
                        document.getElementById('priceName').classList.add('error');
                        return;
                    }

                    if (State.editingPriceId) {
                        // Edit existing price
                        const price = State.prices.find(p => p.id === State.editingPriceId);
                        if (price) {
                            price.name = name;
                            price.price = priceValue;
                        }
                    } else {
                        // Add new price
                        State.prices.push({
                            id: State.nextPriceId++,
                            name: name,
                            price: priceValue
                        });
                    }

                    State.savePrices();
                    this.renderTable();
                    this.closeModal();
                },

                deletePrice(priceId) {
                    const price = State.prices.find(p => p.id === priceId);
                    if (!price) return;

                    // Count how many spots use this price
                    const spotsUsingPrice = Object.values(State.spots).filter(spot => 
                        spot.positioned && spot.priceId === priceId
                    );
                    const spotsCount = spotsUsingPrice.length;

                    // Build confirmation message
                    let message = `Czy na pewno chcesz usunƒÖƒá cenƒô "${price.name}"?`;
                    
                    if (spotsCount > 0) {
                        message = `‚ö†Ô∏è UWAGA! Wybrana cena jest aktualnie u≈ºywana przy ${spotsCount} ${Utils.getPolishPlural(spotsCount)} parkingowych.\n\nJej skasowanie spowoduje wyczyszczenie ca≈Çej konfiguracji i jest nieodwracalne.\n\nCzy na pewno chcesz kontynuowaƒá?`;
                    }

                    if (confirm(message)) {
                        // Remove price from all spots that use it
                        Object.values(State.spots).forEach(spot => {
                            if (spot.priceId === priceId) {
                                spot.priceId = null;
                            }
                        });
                        
                        // Save spots after clearing prices
                        State.saveSpots();
                        
                        // Remove price
                        State.prices = State.prices.filter(p => p.id !== priceId);
                        State.savePrices();
                        
                        // Refresh views
                        this.renderTable();
                        
                        // Refresh Manager if it exists
                        if (app.manager) {
                            app.manager.refreshView();
                        }
                    }
                }
            };

            // ============================================
            // SELLER MODULE
            // ============================================
            const Seller = {
                selectedSpots: new Set(),

                init() {
                    this.renderAvailableSpots();
                    this.renderMap();
                },

                // Get available (unassigned) spots
                getAvailableSpots() {
                    return Object.values(State.spots)
                        .filter(spot => spot.positioned && !spot.vendorId)
                        .sort((a, b) => a.id.localeCompare(b.id, 'pl', { numeric: true }));
                },

                // Render available spots list
                renderAvailableSpots() {
                    const container = document.getElementById('availableSpotsList');
                    const availableSpots = this.getAvailableSpots();

                    if (availableSpots.length === 0) {
                        container.innerHTML = '<div style="color: #999; font-size: 0.85rem; padding: 1rem; text-align: center;">Brak dostƒôpnych miejsc</div>';
                        return;
                    }

                    container.innerHTML = availableSpots.map(spot => {
                        const isSelected = this.selectedSpots.has(spot.id);
                        return `
                            <div class="available-spot-item ${isSelected ? 'selected' : ''}" 
                                 data-spot-id="${spot.id}"
                                 onclick="app.seller.toggleSpot('${spot.id}')">
                                ${spot.id}
                            </div>
                        `;
                    }).join('');
                },

                // Toggle spot selection
                toggleSpot(spotId) {
                    if (this.selectedSpots.has(spotId)) {
                        this.selectedSpots.delete(spotId);
                    } else {
                        this.selectedSpots.add(spotId);
                    }
                    
                    this.renderAvailableSpots();
                    this.renderMap();
                },

                // Clear all selections
                clearSelection() {
                    this.selectedSpots.clear();
                    this.renderAvailableSpots();
                    this.renderMap();
                },

                // Render map with spots
                renderMap() {
                    const overlay = document.getElementById('spotsOverlaySeller');
                    const mapImage = document.getElementById('mapImageSeller');
                    
                    if (!overlay || !mapImage) return;

                    overlay.innerHTML = '';
                    
                    // Use natural dimensions for correct positioning regardless of zoom
                    const naturalWidth = mapImage.naturalWidth || mapImage.width;
                    const naturalHeight = mapImage.naturalHeight || mapImage.height;

                    const availableSpots = this.getAvailableSpots();
                    
                    availableSpots.forEach(spot => {
                        const isSelected = this.selectedSpots.has(spot.id);
                        const backgroundColor = isSelected ? '#ef4444' : '#4b5563'; // Red if selected, dark gray otherwise
                        
                        // Calculate position based on natural dimensions
                        const leftPx = Utils.percentToPx(spot.x, naturalWidth);
                        const topPx = Utils.percentToPx(spot.y, naturalHeight);
                        
                        const rect = document.createElement('div');
                        rect.className = 'seller-parking-spot';
                        rect.dataset.spotId = spot.id;
                        
                        rect.style.left = leftPx + 'px';
                        rect.style.top = topPx + 'px';
                        rect.style.width = spot.width + 'px';
                        rect.style.height = spot.height + 'px';
                        rect.style.transform = `rotate(${spot.rotation}deg)`;
                        rect.style.transformOrigin = 'center center';
                        rect.style.backgroundColor = backgroundColor;
                        rect.style.border = `2px solid ${backgroundColor}`;
                        
                        // Create label element (like Manager does)
                        const label = document.createElement('div');
                        label.className = 'spot-label';
                        label.style.color = '#ffffff'; // White text for seller spots
                        label.textContent = spot.id;
                        label.style.transform = spot.height > spot.width ? 
                            'translate(-50%, -50%) rotate(90deg)' : 
                            'translate(-50%, -50%)';
                        
                        rect.appendChild(label);
                        
                        rect.addEventListener('click', () => {
                            this.toggleSpot(spot.id);
                        });
                        
                        rect.addEventListener('dblclick', (e) => {
                            e.stopPropagation();
                            this.clearSelection();
                        });
                        
                        overlay.appendChild(rect);
                    });

                    // Add double-click handler to overlay for clearing selection
                    overlay.ondblclick = (e) => {
                        if (e.target === overlay) {
                            this.clearSelection();
                        }
                    };
                }
            };

            // ============================================
            // UI MODULE
            // ============================================
            const UI = {
                init() {
                    // Initialize UI state
                    this.updateZoomDisplay();
                    
                    // Initialize panning
                    this.initPanning();
                    
                    // Render initial Manager view (since it's the default tab)
                    app.manager.refreshView();
                },

                switchTab(tabName) {
                    State.currentTab = tabName;
                    
                    // Update tab buttons
                    document.querySelectorAll('.tab-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    event.target.classList.add('active');
                    
                    // Update tab content
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    if (tabName === 'designer') {
                        document.getElementById('designerTab').classList.add('active');
                        this.applyZoom(); // Apply designer zoom
                        app.designer.updateUI(); // Refresh spot list to show current states
                    } else if (tabName === 'manager') {
                        document.getElementById('managerTab').classList.add('active');
                        this.applyZoom(); // Apply manager zoom
                        app.manager.refreshView();
                    } else if (tabName === 'seller') {
                        document.getElementById('sellerTab').classList.add('active');
                        this.applyZoom(); // Apply seller zoom
                        app.seller.init();
                    } else if (tabName === 'vendors') {
                        document.getElementById('vendorsTab').classList.add('active');
                        app.vendors.renderTable();
                    } else if (tabName === 'prices') {
                        document.getElementById('pricesTab').classList.add('active');
                        app.prices.renderTable();
                    }
                },

                zoomIn() {
                    let oldZoom, newZoom, currentZoom;
                    
                    if (State.currentTab === 'designer') {
                        currentZoom = State.designerZoom;
                    } else if (State.currentTab === 'seller') {
                        currentZoom = State.sellerZoom;
                    } else {
                        currentZoom = State.managerZoom;
                    }
                    
                    oldZoom = currentZoom;
                    
                    // Round up to next full hundred
                    // e.g., 1.23 ‚Üí 2.0, 2.78 ‚Üí 3.0, 5.0 ‚Üí 6.0
                    newZoom = Math.ceil(currentZoom);
                    
                    // Ensure minimum increment of 1 (100%)
                    if (newZoom <= currentZoom) {
                        newZoom = currentZoom + 1;
                    }
                    
                    // Apply max limit (10 = 1000%)
                    newZoom = Math.min(newZoom, CONSTANTS.MAX_ZOOM);
                    
                    // Update state
                    if (State.currentTab === 'designer') {
                        State.designerZoom = newZoom;
                    } else if (State.currentTab === 'seller') {
                        State.sellerZoom = newZoom;
                    } else {
                        State.managerZoom = newZoom;
                    }
                    
                    this.applyZoomWithCenter(oldZoom, newZoom);
                },

                zoomOut() {
                    let oldZoom, newZoom, currentZoom;
                    
                    if (State.currentTab === 'designer') {
                        currentZoom = State.designerZoom;
                    } else if (State.currentTab === 'seller') {
                        currentZoom = State.sellerZoom;
                    } else {
                        currentZoom = State.managerZoom;
                    }
                    
                    oldZoom = currentZoom;
                    
                    // Round down to previous full hundred
                    // e.g., 2.23 ‚Üí 2.0, 8.78 ‚Üí 8.0, 5.0 ‚Üí 4.0
                    newZoom = Math.floor(currentZoom);
                    
                    // Ensure minimum decrement of 1 (100%)
                    if (newZoom >= currentZoom) {
                        newZoom = currentZoom - 1;
                    }
                    
                    // Apply min limit (1 = 100%)
                    newZoom = Math.max(newZoom, CONSTANTS.MIN_ZOOM);
                    
                    // Update state
                    if (State.currentTab === 'designer') {
                        State.designerZoom = newZoom;
                    } else if (State.currentTab === 'seller') {
                        State.sellerZoom = newZoom;
                    } else {
                        State.managerZoom = newZoom;
                    }
                    
                    this.applyZoomWithCenter(oldZoom, newZoom);
                },

                zoomReset() {
                    let oldZoom;
                    
                    if (State.currentTab === 'designer') {
                        oldZoom = State.designerZoom;
                        State.designerZoom = 1;
                    } else if (State.currentTab === 'seller') {
                        oldZoom = State.sellerZoom;
                        State.sellerZoom = 1;
                    } else {
                        oldZoom = State.managerZoom;
                        State.managerZoom = 1;
                    }
                    
                    this.applyZoomWithCenter(oldZoom, 1);
                },

                applyZoomWithCenter(oldZoom, newZoom) {
                    let container, scaleContainer;
                    
                    if (State.currentTab === 'designer') {
                        container = document.getElementById('mapContainer');
                        scaleContainer = document.getElementById('mapScaleContainer');
                    } else if (State.currentTab === 'seller') {
                        container = document.getElementById('mapContainerSeller');
                        scaleContainer = document.getElementById('mapScaleContainerSeller');
                    } else {
                        container = document.getElementById('mapContainerManager');
                        scaleContainer = document.getElementById('mapScaleContainerManager');
                    }
                    
                    if (!container || !scaleContainer) {
                        this.applyZoom();
                        return;
                    }
                    
                    // Get current scroll position and container dimensions
                    const scrollX = container.scrollLeft;
                    const scrollY = container.scrollTop;
                    const containerWidth = container.clientWidth;
                    const containerHeight = container.clientHeight;
                    
                    // Calculate center point in the current zoom
                    const centerX = scrollX + containerWidth / 2;
                    const centerY = scrollY + containerHeight / 2;
                    
                    // Apply new zoom to scale container
                    if (State.currentTab === 'designer') {
                        scaleContainer.style.transform = `scale(${State.designerZoom})`;
                    } else if (State.currentTab === 'seller') {
                        scaleContainer.style.transform = `scale(${State.sellerZoom})`;
                    } else {
                        scaleContainer.style.transform = `scale(${State.managerZoom})`;
                    }
                    
                    // Calculate new scroll position to maintain center
                    const zoomRatio = newZoom / oldZoom;
                    const newScrollX = centerX * zoomRatio - containerWidth / 2;
                    const newScrollY = centerY * zoomRatio - containerHeight / 2;
                    
                    // Apply new scroll position
                    container.scrollLeft = newScrollX;
                    container.scrollTop = newScrollY;
                    
                    this.updateZoomDisplay();
                },

                applyZoom() {
                    const designerScaleContainer = document.getElementById('mapScaleContainer');
                    const managerScaleContainer = document.getElementById('mapScaleContainerManager');
                    const sellerScaleContainer = document.getElementById('mapScaleContainerSeller');
                    
                    if (designerScaleContainer) {
                        designerScaleContainer.style.transform = `scale(${State.designerZoom})`;
                    }
                    if (managerScaleContainer) {
                        managerScaleContainer.style.transform = `scale(${State.managerZoom})`;
                    }
                    if (sellerScaleContainer) {
                        sellerScaleContainer.style.transform = `scale(${State.sellerZoom})`;
                    }
                    
                    this.updateZoomDisplay();
                },

                updateZoomDisplay() {
                    const designerZoomPercent = Math.round(State.designerZoom * 100) + '%';
                    const managerZoomPercent = Math.round(State.managerZoom * 100) + '%';
                    const sellerZoomPercent = Math.round(State.sellerZoom * 100) + '%';
                    
                    const designerInput = document.getElementById('zoomLevel');
                    const managerInput = document.getElementById('zoomLevelManager');
                    const sellerInput = document.getElementById('zoomLevelSeller');
                    
                    if (designerInput) designerInput.value = designerZoomPercent;
                    if (managerInput) managerInput.value = managerZoomPercent;
                    if (sellerInput) sellerInput.value = sellerZoomPercent;
                },

                handleZoomInput(event, tab) {
                    // Only handle Enter key
                    if (event.key !== 'Enter') return;
                    
                    event.preventDefault();
                    
                    const input = event.target;
                    let value = input.value.trim();
                    
                    // Remove % sign if present
                    value = value.replace('%', '');
                    
                    // Parse as number
                    const zoomPercent = parseInt(value);
                    
                    // Validate range 100-1000
                    if (isNaN(zoomPercent) || zoomPercent < 100 || zoomPercent > 1000) {
                        // Invalid - restore current value
                        this.updateZoomDisplay();
                        input.blur();
                        return;
                    }
                    
                    // Calculate new zoom level (100% = 1.0, 200% = 2.0, etc.)
                    let oldZoom;
                    if (tab === 'designer') {
                        oldZoom = State.designerZoom;
                    } else if (tab === 'seller') {
                        oldZoom = State.sellerZoom;
                    } else {
                        oldZoom = State.managerZoom;
                    }
                    
                    const newZoom = zoomPercent / 100;
                    
                    // Update state
                    if (tab === 'designer') {
                        State.designerZoom = newZoom;
                    } else if (tab === 'seller') {
                        State.sellerZoom = newZoom;
                    } else {
                        State.managerZoom = newZoom;
                    }
                    
                    // Apply zoom with center preservation
                    this.applyZoomWithCenter(oldZoom, newZoom);
                    
                    // Remove focus from input
                    input.blur();
                },

                // ============================================
                // PANNING METHODS
                // ============================================
                initPanning() {
                    // Listen for Control key globally
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Control' && !State.isControlPressed) {
                            State.isControlPressed = true;
                            this.updatePanningCursor();
                        }
                    });

                    document.addEventListener('keyup', (e) => {
                        if (e.key === 'Control') {
                            State.isControlPressed = false;
                            State.isPanning = false;
                            this.updatePanningCursor();
                        }
                    });

                    // Setup panning for all map containers
                    this.setupMapPanning('mapContainer');           // Designer
                    this.setupMapPanning('mapContainerManager');    // Manager
                    this.setupMapPanning('mapContainerSeller');     // Seller
                },

                setupMapPanning(containerId) {
                    const container = document.getElementById(containerId);
                    if (!container) return;

                    // Mouse enter/leave for cursor update
                    container.addEventListener('mouseenter', () => {
                        this.updatePanningCursor();
                    });

                    container.addEventListener('mouseleave', () => {
                        container.classList.remove('can-pan', 'is-panning');
                        if (State.isPanning) {
                            State.isPanning = false;
                        }
                    });

                    // Mouse down - start panning
                    container.addEventListener('mousedown', (e) => {
                        if (!State.isControlPressed) return;
                        
                        // Check if zoom > 100%
                        const currentZoom = this.getCurrentZoom();
                        if (currentZoom <= 1) return; // No panning at 100%

                        e.preventDefault();
                        State.isPanning = true;
                        State.panStartX = e.clientX;
                        State.panStartY = e.clientY;
                        State.panScrollLeft = container.scrollLeft;
                        State.panScrollTop = container.scrollTop;

                        container.classList.add('is-panning');
                        container.classList.remove('can-pan');
                    });

                    // Mouse move - do panning
                    container.addEventListener('mousemove', (e) => {
                        if (!State.isPanning) return;

                        e.preventDefault();
                        
                        const dx = e.clientX - State.panStartX;
                        const dy = e.clientY - State.panStartY;

                        container.scrollLeft = State.panScrollLeft - dx;
                        container.scrollTop = State.panScrollTop - dy;
                    });

                    // Mouse up - stop panning
                    container.addEventListener('mouseup', () => {
                        if (State.isPanning) {
                            State.isPanning = false;
                            this.updatePanningCursor();
                        }
                    });

                    // Global mouse up (in case mouse leaves container while dragging)
                    document.addEventListener('mouseup', () => {
                        if (State.isPanning) {
                            State.isPanning = false;
                            container.classList.remove('is-panning');
                            this.updatePanningCursor();
                        }
                    });
                },

                updatePanningCursor() {
                    const containers = [
                        'mapContainer',
                        'mapContainerManager',
                        'mapContainerSeller'
                    ];

                    containers.forEach(id => {
                        const container = document.getElementById(id);
                        if (!container) return;

                        // Remove all classes first
                        container.classList.remove('can-pan', 'is-panning');

                        // Add appropriate class
                        if (State.isPanning) {
                            container.classList.add('is-panning');
                        } else if (State.isControlPressed) {
                            const currentZoom = this.getCurrentZoom();
                            if (currentZoom > 1) {
                                container.classList.add('can-pan');
                            }
                        }
                    });
                },

                getCurrentZoom() {
                    if (State.currentTab === 'designer') {
                        return State.designerZoom;
                    } else if (State.currentTab === 'seller') {
                        return State.sellerZoom;
                    } else {
                        return State.managerZoom;
                    }
                },

                toggleInstructions() {
                    const box = document.getElementById('instructionBox');
                    box.classList.toggle('hidden');
                },

                closeExportModal() {
                    document.getElementById('exportModal').classList.remove('show');
                },

                copyToClipboard() {
                    const textarea = document.getElementById('exportTextarea');
                    textarea.select();
                    document.execCommand('copy');
                    alert('Wsp√≥≈Çrzƒôdne skopiowane do schowka!');
                }
            };

            // ============================================
            // PUBLIC API
            // ============================================
            return {
                state: State,
                storage: StorageDB,
                utils: Utils,
                designer: Designer,
                manager: Manager,
                seller: Seller,
                vendors: Vendors,
                prices: Prices,
                ui: UI,

                async init() {
                    await State.init();
                    Designer.init();
                    Manager.init();
                    Vendors.init();
                    Prices.init();
                    UI.init();
                }
            };
        })();

        // Initialize application
        const app = ParkingApp;
        
        // Wait for DOM and image to load
        window.addEventListener('load', async () => {
            // Initialize with IndexedDB storage
            await app.init();
        });
    </script>
</body>
</html>
